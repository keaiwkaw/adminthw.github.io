<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Sass的基本使用</title>
    <url>/2021/02/05/Sass%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="快速上手Sass"><a href="#快速上手Sass" class="headerlink" title="快速上手Sass"></a>快速上手Sass</h1><p>一直说学下css的预编译器，在less和sass之间我选择了sass</p>
<p>废话少说吧，接下来2介绍sass的使用，</p>
<h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h2><p>例如 <code>$bgClolor : #FFF;</code> ,在css中就可以直接使用 <code>background:$bgClolor;</code></p>
<h2 id="2-作用域的概念"><a href="#2-作用域的概念" class="headerlink" title="2.作用域的概念"></a>2.作用域的概念</h2><p>在sass中如果变量写在 <strong>{}</strong> 里面，则变量只在**{}**里面有效</p>
<a id="more"></a>

<h2 id="3-中划线和下划线"><a href="#3-中划线和下划线" class="headerlink" title="3.中划线和下划线"></a>3.中划线和下划线</h2><p><em>在sass中是不严格区分中划线和下划线的</em>，这个意思就是，当你声明的变量是中划线时，调用的时候你完全可以使用下划线来调用(反之亦然)</p>
<p>例如<code> $background-color:#ddd;   background:$background_color;</code></p>
<p>4.嵌套原理</p>
<p>例如 </p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"></span><br><span class="line">​	<span class="selector-tag">p</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译后</span></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>所以当你想给div 添加伪类时，该怎么操作呢？在sass中提供了 &amp; 这个代表父级，所以伪类 &amp;:hover{}  这样就好</p>
<p><strong>特殊的：</strong></p>
<p>例如我们写<code>background-color:; background-image:; </code>这样就会重复写很多，sass提供了这样的写法</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>:&#123;</span><br><span class="line"></span><br><span class="line">	image:;</span><br><span class="line"></span><br><span class="line">	<span class="attribute">color</span>:;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="5-导入"><a href="#5-导入" class="headerlink" title="5.导入"></a>5.导入</h2><p>在css文件中可以使用 @import 的方式导入css文件，在sass中也可以且可以省略文件后缀，在普通css文件使用@import导入时，解析到该条语句，导入的css文件才会加载，但在sass中，不会出现这样的问题。</p>
<p>如果导入别的文件，别的文件中的变量，你的文件中也有，所以就会产生覆盖现象，你可以为你的变量添加 !default 当文件有这个变量时，使用这个变量，当没有时，使用默认值</p>
<p>​    嵌套导入 ：你可以在{} 里使用@import</p>
<h2 id="6-注释"><a href="#6-注释" class="headerlink" title="6.注释"></a>6.注释</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  color: #333; &#x2F;&#x2F; 这种注释内容不会出现在生成的css文件中</span><br><span class="line">  padding: 0; &#x2F;* 这种注释内容会出现在生成的css文件中 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-混合器"><a href="#7-混合器" class="headerlink" title="7.混合器"></a>7.混合器</h2><p>用 @mixin定义 用@ include使用</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> mymixin &#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">	<span class="keyword">@include</span> mymixin</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个包含CSS规则的混合器通过过<code>@include</code>包含在一个父规则中时，在混合器中的规则最终会生成父规则中的嵌套规则@mi</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> mymixin &#123;</span><br><span class="line">    <span class="selector-tag">p</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">        <span class="selector-tag">a</span>&#123;</span><br><span class="line">            <span class="attribute">font-size</span>: <span class="number">20px</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">body&#123;</span><br><span class="line">  @include mymixin</span><br><span class="line">&#125;</span><br><span class="line">//会被解析为</span><br><span class="line">body p &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>传参和默认值</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> link-colors(<span class="variable">$normal</span>:<span class="variable">$normal</span>, <span class="variable">$hover</span>, <span class="variable">$visited</span>) &#123;</span><br><span class="line">    <span class="comment">//默认值可以时指定的值，也可以是某个变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@include</span> link-colors(<span class="variable">$normal</span>:value, <span class="variable">$hover</span>:value, <span class="variable">$visited</span>:value) //这样写就知道每个参数对应的值</span><br></pre></td></tr></table></figure>
<h2 id="6-选择器继承"><a href="#6-选择器继承" class="headerlink" title="6.选择器继承"></a>6.选择器继承</h2><p>@extend</p>
<p>和原选择器有关的组合选择器都会以组合选择器的形式继承</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.seriousError从.error继承样式</span></span><br><span class="line"><span class="selector-class">.error</span> <span class="selector-tag">a</span>&#123;  <span class="comment">//应用到.seriousError a</span></span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-class">.error</span> &#123; <span class="comment">//应用到hl.seriousError</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Sass</tag>
        <tag>CSS预编译器</tag>
      </tags>
  </entry>
  <entry>
    <title>AST and Render</title>
    <url>/2021/02/10/AST_render/</url>
    <content><![CDATA[<blockquote>
<p>前言：最近在学习AST树的相关概念，越来越多的知识要学习，要学习的东西也越来越难，之前的东西也忘的差不多，所以还是要认真学认真复习。</p>
<p>文章对字符串和正则的水平要求高。扪心自问，我写不出这样的代码。</p>
</blockquote>
<h1 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h1><p>AST （Abstract syntax tree—抽象语法树，抽象语法树就是把某一个结构用树形描述出来。例如一段程序，一个DOM结构等等</p>
<p>在Vue的模板编译中，就需要将模板，也就是DOM结构首先编译成 AST 再进行下步的操作，基本的思想就是将DOM模板当成纯字符串处理，每处理一部分就删除一部分直到模板为空。</p>
<a id="more"></a>

<h2 id="parseHtmlToAST"><a href="#parseHtmlToAST" class="headerlink" title="parseHtmlToAST"></a>parseHtmlToAST</h2><p>这个函数的作用就是将模板转化成AST</p>
<p>在转化前需要用到一系列的正则 这些正则可以在<a href="https://github.com/vuejs/vue/blob/dev/src/compiler/parser/html-parser.js">Vue的源码</a>中找到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> attribute = <span class="regexp">/^\s*([^\s&quot;&#x27;&lt;&gt;\/=]+)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\s&quot;&#x27;=&lt;&gt;`]+)))?/</span>;  <span class="comment">//匹配属性</span></span><br><span class="line"><span class="keyword">const</span> dynamicArgAttribute = <span class="regexp">/^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s&quot;&#x27;&lt;&gt;\/=]*)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\s&quot;&#x27;=&lt;&gt;`]+)))?/</span>;</span><br><span class="line"><span class="keyword">const</span> ncname = <span class="string">`[a-zA-Z_][\\-\\.0-9_a-zA-Z]*`</span>;</span><br><span class="line"><span class="keyword">const</span> qnameCapture = <span class="string">`((?:<span class="subst">$&#123;ncname&#125;</span>\\:)?<span class="subst">$&#123;ncname&#125;</span>)`</span>;</span><br><span class="line"><span class="keyword">const</span> startTagOpen = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`^&lt;<span class="subst">$&#123;qnameCapture&#125;</span>`</span>);          <span class="comment">//匹配标签的开始</span></span><br><span class="line"><span class="keyword">const</span> startTagClose = <span class="regexp">/^\s*(\/?)&gt;/</span>;                  <span class="comment">//匹配标签的结束</span></span><br><span class="line"><span class="keyword">const</span> endTag = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`^&lt;\\/<span class="subst">$&#123;qnameCapture&#125;</span>[^&gt;]*&gt;`</span>);   <span class="comment">//匹配结束标签</span></span><br></pre></td></tr></table></figure>
<p>需要用到以下变量</p>
<ul>
<li>text         保存匹配到的文本</li>
<li>root         保存AST树</li>
<li>currentParent      当前元素的父元素</li>
<li>stack        利用进栈出栈操作模拟出谁是谁的子元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (html) &#123;</span><br><span class="line">   <span class="keyword">let</span> textEnd = html.indexOf(<span class="string">&quot;&lt;&quot;</span>);   <span class="comment">//查找 &lt;  位置</span></span><br><span class="line">   <span class="keyword">if</span> (textEnd === <span class="number">0</span>) &#123;  <span class="comment">//开头出现</span></span><br><span class="line">     <span class="keyword">const</span> startTagMatch = parseStartTag();  <span class="comment">//返回标签的名称与属性</span></span><br><span class="line">     <span class="keyword">if</span> (startTagMatch) &#123;   </span><br><span class="line">       start(startTagMatch.tagName, startTagMatch.attrs);  <span class="comment">//匹配到开始标签，交给start函数</span></span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">const</span> endTgaMatch = html.match(endTag);        </span><br><span class="line">     <span class="keyword">if</span> (endTgaMatch) &#123;        </span><br><span class="line">       advance(endTgaMatch[<span class="number">0</span>].length); </span><br><span class="line">       end(endTgaMatch[<span class="number">1</span>]);          <span class="comment">//匹配到结束标签，交给end函数</span></span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (textEnd &gt; <span class="number">0</span>) &#123;   <span class="comment">//&lt; 未出现在开头，需要截取这部分 </span></span><br><span class="line">     text = html.substring(<span class="number">0</span>, textEnd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (text) &#123;    <span class="comment">//判段该部分文字是否需要chars() 处理</span></span><br><span class="line">     advance(text.length);</span><br><span class="line">     chars(text);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>当模板不为空就需要一直的操作下去，检测标签开始判断标签开始是否在第一位，如果不在说明前面有文字，截取掉文字后继续处理</p>
<h3 id="parseStartTag"><a href="#parseStartTag" class="headerlink" title="parseStartTag"></a>parseStartTag</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> match = &#123;</span><br><span class="line">        tagName: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        attrs: [],</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure>
<p>返回如下结构，标签名称与属性</p>
<h3 id="start-tagName-attrs"><a href="#start-tagName-attrs" class="headerlink" title="start(tagName, attrs)"></a>start(<em>tagName</em>, <em>attrs</em>)</h3><p>如果root 存在则给currentParent赋值为当前元素，并将当前元素入栈</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = createASTElement(tagName, attrs);</span><br><span class="line">   <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">     root = element;</span><br><span class="line">   &#125;</span><br><span class="line">   currentParent = element;</span><br><span class="line">   stack.push(element);</span><br></pre></td></tr></table></figure>


<h3 id="end-tagName"><a href="#end-tagName" class="headerlink" title="end(tagName)"></a>end(tagName)</h3><p>调用end函数说明遇到了结束标签这时候就要从栈取出父元素并同时给当前元素的parent属性赋值，给父元素的children元素push当前元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">onst element = stack.pop();</span><br><span class="line">    currentParent = stack[stack.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (currentParent) &#123;</span><br><span class="line">      element.parent = currentParent;</span><br><span class="line">      currentParent.children.push(element);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="chars-text"><a href="#chars-text" class="headerlink" title="chars(text)"></a>chars(<em>text</em>)</h3><p>对截取的文本进行处理，如果文本*trim()*后存在的话，将该文本压入到父元素的儿子中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">currentParent.children.push(&#123;</span><br><span class="line">       type: <span class="number">3</span>,</span><br><span class="line">       text,</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure>




<h3 id="createASTElement-tagName-attrs"><a href="#createASTElement-tagName-attrs" class="headerlink" title="createASTElement(tagName, attrs)"></a>createASTElement(<em>tagName</em>, <em>attrs</em>)</h3><p>供start函数调用，返回元素的基本信息</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">     tag: tagName,</span><br><span class="line">     type: <span class="number">1</span>,</span><br><span class="line">     children: [],</span><br><span class="line">     attrs,</span><br><span class="line">     parent,</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<p>疑问一：为什么出栈入栈操作可以模拟出元素的层次结构呢？</p>
<p>答：**栈中最后一个元素的父级总是前一个元素 ** 例如 :<code>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;</code></p>
<p>[div,p] 先碰到<code>&lt;div&gt;</code>div入栈，碰到<code>&lt;p&gt; </code>p入栈,碰到<code>&lt;/p&gt;</code> p 出栈父元素赋值为p的前一个元素（div）</p>
<h3 id="advance-n"><a href="#advance-n" class="headerlink" title="advance(n)"></a>advance(<em>n</em>)</h3><p>删除已经处理过的字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">html = html.substring(n);</span><br></pre></td></tr></table></figure>
<p>最终生成AST的样子：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a66b84d9dfde8b3edc52de1dcb2ba647.png" alt="image-20210210155508979"></p>
<h1 id="render"><a href="#render" class="headerlink" title="render"></a>render</h1><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>在返回render函数之前首先要对AST进行处理生成code </p>
<p>建议看下面的生成好的代码，可以更快速的了解属性等东西要拼凑成什么样子的字符串</p>
<p><code>const defaultTagRE = /\&#123;\&#123;((?:.|\r?\n)+?)\&#125;\&#125;/g; //匹配双大括号</code></p>
<h3 id="generate-el"><a href="#generate-el" class="headerlink" title="generate(el)"></a>generate(el)</h3><p>返回code字符串,处理标签元素的的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> children = getChildren(el),</span><br><span class="line">    code = <span class="string">`_c(&#x27;<span class="subst">$&#123;el.tag&#125;</span>&#x27;,<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">      el.attrs.length &gt; <span class="number">0</span> ? <span class="string">`<span class="subst">$&#123;formatProps(el.attrs)&#125;</span>`</span> : <span class="string">&quot;undefined&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span><span class="subst">$&#123;children ? <span class="string">`,<span class="subst">$&#123;children&#125;</span>`</span> : <span class="string">&quot;&quot;</span>&#125;</span>)`</span>;</span><br><span class="line">  <span class="keyword">return</span> code;</span><br></pre></td></tr></table></figure>
<h3 id="generateChild-node"><a href="#generateChild-node" class="headerlink" title="generateChild(node)"></a>generateChild(node)</h3><p>供getchildren函数调用，根据node.type的类型不同做出不同的处理，当是文本节点时，就要判断<code>&#123;&#123;&#125;&#125;</code>出现的位置，并进行合适的拼凑</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (node.type === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> generate(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.type === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> text = node.text;</span><br><span class="line">    <span class="keyword">if</span> (!defaultTagRE.test(text)) &#123;  <span class="comment">//匹配不到&#123;&#123;&#125;&#125;，说明是纯文本节点</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">`_v(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(text)&#125;</span>)`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> match,</span><br><span class="line">      index,</span><br><span class="line">      lastIndex = (defaultTagRE.lastIndex = <span class="number">0</span>),</span><br><span class="line">      textArr = [];</span><br><span class="line">    <span class="keyword">while</span> ((match = defaultTagRE.exec(text))) &#123;</span><br><span class="line">      index = match.index;</span><br><span class="line">      <span class="keyword">if</span> (index &gt; lastIndex) &#123;     <span class="comment">//&#123;&#123;之前有文本， 将文本压入textARR</span></span><br><span class="line">        textArr.push(<span class="built_in">JSON</span>.stringify(text.slice(lastIndex, index)));</span><br><span class="line">      &#125;</span><br><span class="line">      textArr.push(<span class="string">`_s(<span class="subst">$&#123;match[<span class="number">1</span>].trim()&#125;</span>)`</span>);  <span class="comment">// 将变量按_s&#123;name&#125; 的字符压入  textARR</span></span><br><span class="line">      lastIndex = index + match[<span class="number">0</span>].length;     <span class="comment">//正则指针后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lastIndex &lt; text.length) &#123;    <span class="comment">//处理&#125;&#125;后还有文本的情况     </span></span><br><span class="line">      textArr.push(<span class="built_in">JSON</span>.stringify(text.slice(lastIndex)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`_v(<span class="subst">$&#123;textArr.join(<span class="string">&quot;+&quot;</span>)&#125;</span>)`</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h3 id="getChildren-el"><a href="#getChildren-el" class="headerlink" title="getChildren(el)"></a>getChildren(el)</h3><p>遍历每一个children并拼凑成合适的字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> children = el.children;</span><br><span class="line"> <span class="keyword">if</span> (children) &#123;</span><br><span class="line">   <span class="keyword">return</span> children.map(<span class="function">(<span class="params">c</span>) =&gt;</span> generateChild(c)).join(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<h3 id="formatProps-attrs"><a href="#formatProps-attrs" class="headerlink" title="formatProps(attrs)"></a>formatProps(attrs)</h3><p>对属性处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> attrStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; attrs.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> attr = attrs[i];</span><br><span class="line">    <span class="keyword">if</span> (attr.name === <span class="string">&quot;style&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> styleAttrs = &#123;&#125;;</span><br><span class="line">      attr.value.split(<span class="string">&quot;;&quot;</span>).map(<span class="function">(<span class="params">styleAttr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> [key, value] = styleAttr.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        styleAttrs[key] = value;</span><br><span class="line">      &#125;);</span><br><span class="line">      attr.value = styleAttrs;</span><br><span class="line">    &#125;</span><br><span class="line">    attrStr += <span class="string">`<span class="subst">$&#123;attr.name&#125;</span>:<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(attr.value)&#125;</span>,`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`&#123;<span class="subst">$&#123;attrStr.slice(<span class="number">0</span>, -<span class="number">1</span>)&#125;</span>&#125;`</span>;</span><br></pre></td></tr></table></figure>


<p>下面的3个方法是挂载到Vue的原型上，所以在vm实例中是可以访问到的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">_c()    创建标签节点</span><br><span class="line"></span><br><span class="line">_v()    创建文本节点</span><br><span class="line"></span><br><span class="line">_s()     当遇到&#123;&#123;&#125;&#125;时用 _s()包裹</span><br></pre></td></tr></table></figure>


<p>生成的结果如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">_c(&#x27;div&#x27;,</span><br><span class="line">&#123;id:&quot;content&quot;&#125;,</span><br><span class="line">_c(&#x27;header&#x27;,</span><br><span class="line">    undefined,</span><br><span class="line">    _c(&#x27;div&#x27;,</span><br><span class="line">        &#123;class:&quot;btn-group&quot;,style:&#123;&quot;color&quot;:&quot; red&quot;,&quot; font-size&quot;:&quot; 15px&quot;&#125;&#125;,</span><br><span class="line">        _c(&#x27;button&#x27;,</span><br><span class="line">            &#123;class:&quot;.f-input&quot;&#125;),</span><br><span class="line">        _c(&#x27;button&#x27;,</span><br><span class="line">            &#123;class:&quot;.f-input&quot;&#125;)),</span><br><span class="line">     _c(&#x27;section&#x27;,undefined,_v(&quot;我是&quot;+_s(name)))),</span><br><span class="line">_c(&#x27;footer&#x27;,</span><br><span class="line">undefined))</span><br></pre></td></tr></table></figure>
<p>这里为了好看，我做了换行处理，为的是看清楚谁是谁的儿子</p>
<h3 id="render-1"><a href="#render-1" class="headerlink" title="render"></a>render</h3><p>将code包裹并返回一个函数–render函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(</span><br><span class="line">              <span class="string">`with(this)&#123;</span></span><br><span class="line"><span class="string">              return <span class="subst">$&#123;code&#125;</span></span></span><br><span class="line"><span class="string">    		&#125;`</span></span><br><span class="line">   		 )</span><br></pre></td></tr></table></figure>
<p>疑问一： 为什么要返回一个with包裹的this的函数 这里的this指向的是谁？</p>
<p>答：this指的是当前的vm实例对象，用with包裹是因为不用使用this.xxx来调用，省去了重复书写this的麻烦</p>
<p>new Function() 执行时会将字符串当作JS语句执行</p>
<blockquote>
<p>总结：文章内容对字符串的处理详细，在拼凑格式上有很高的要求，在正则表达式上需要很高的水准，在模板字符串的嵌套中嵌套模板字符串。上次写的计划，还是删了吧，我好像不是一个自律的人儿呢</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue核心</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise、call、apply的实现</title>
    <url>/2021/01/26/Promise%E3%80%81call%E3%80%81apply%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p><strong>基本思想</strong></p>
<ul>
<li>异步操作的任务使用<code>setTimeout</code>完成</li>
<li>错误处理采用<code>try catch</code>语句块完成</li>
<li>then的链式操作理解为一个递归操作</li>
</ul>
<h3 id="基本的架构如下"><a href="#基本的架构如下" class="headerlink" title="基本的架构如下"></a>基本的架构如下</h3><a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> PENDING = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> FULFILLED = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> REJECTED = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">ex</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.status = myPromise.PENDING;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.callbacks = [];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ex(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="built_in">this</span>.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="title">then</span>(<span class="params">onFulfilled,onRejected</span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve:"></a>resolve:</h3><p>当是解决的时候值改变状态改变，为达到异步操作的目的这里使用<code>setTimeout</code>并在数组里执行相对应的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status == myPromise.PENDING) &#123;</span><br><span class="line">    <span class="built_in">this</span>.status = myPromise.FULFILLED;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.callbacks.map(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">        callback.onFulfilled(value);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="reject"><a href="#reject" class="headerlink" title="reject:"></a>reject:</h3><p>reject的情况和resolve如出一辙</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status == myPromise.PENDING) &#123;</span><br><span class="line">    <span class="built_in">this</span>.status = myPromise.REJECTED;</span><br><span class="line">    <span class="built_in">this</span>.value = reason;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.callbacks.map(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">        callback.onRejected(reason);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="then："><a href="#then：" class="headerlink" title="then："></a>then：</h3><p>将then的代码拆开来看</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//第一部分</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> onFulfilled != <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">     onFulfilled = <span class="function">() =&gt;</span> <span class="built_in">this</span>.value;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected != <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">     onRejected = <span class="function">() =&gt;</span> <span class="built_in">this</span>.value;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里为什么要判断给then传入的函数类型呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,rejected</span>)=&gt;</span>&#123;</span><br><span class="line">     resolve(<span class="string">&quot;123&quot;</span>)    </span><br><span class="line">   &#125;).then().then(<span class="function"><span class="params">v</span>=&gt;</span><span class="built_in">console</span>.log(v))  <span class="comment">//就是为了解决then的穿透问题</span></span><br></pre></td></tr></table></figure>
<p>接下来看第二段代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status == myPromise.PENDING) &#123;</span><br><span class="line">        <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">          onFulfilled: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.parse(promise, onFulfilled(value), resolve, reject);</span><br><span class="line">          &#125;,</span><br><span class="line"></span><br><span class="line">          onRejected: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.parse(promise, onRejected(value), resolve, reject);</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status == myPromise.REJECTED) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.parse(promise, onRejected(<span class="built_in">this</span>.value), resolve, reject);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status == myPromise.FULFILLED) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.parse(promise, onFulfilled(<span class="built_in">this</span>.value), resolve, reject);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br></pre></td></tr></table></figure>
<p>你可能会问直接将promise返回出去就完事了，干嘛还声明一个变量再返回出去。</p>
<p>在原生中promise是不允许返回自身的 如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">       resolve(<span class="string">&quot;解决&quot;</span>)</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">let</span> p2=p1.then(<span class="function"><span class="params">value</span>=&gt;</span>p2)</span><br></pre></td></tr></table></figure>
<p>以上的代码会报错</p>
<p><code>Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</code></p>
<p>看到这里你可能已经猜到parse函数是用来减少代码冗杂的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">parse</span>(<span class="params">promise, result, resolve, reject</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promise == result) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Chaining cycle detected&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (result <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">        result.then(resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>和上面的代码对照你会发现这里传入的result表示的是上一次then的结果，在原生中then是可以返回promise的，所以在这里对返回的结果进行判断，</p>
<hr>

<p>考虑到promise有3个状态，所以在创建promise时初始化了一个数组在状态改变时在数组里直接获取相对应的函数</p>
<p>将相对应得函数压到数组中有什么好处或者说是可以解决什么问题呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,rejected</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            resolve(<span class="string">&quot;解决&quot;</span>)</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;第一个输出&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;).then(<span class="function"><span class="params">v</span>=&gt;</span><span class="built_in">console</span>.log(v))  <span class="comment">//解决是第二个输出的  </span></span><br></pre></td></tr></table></figure>
<p><code>setTimeout</code>产生的是个宏任务，所以在1s后promise的状态才会改变所以“解决”在“第一个输出”的后面输出</p>
<h3 id="promise中的一些方法和接口"><a href="#promise中的一些方法和接口" class="headerlink" title="promise中的一些方法和接口"></a>promise中的一些方法和接口</h3><h4 id="resolve-1"><a href="#resolve-1" class="headerlink" title="resolve"></a>resolve</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">      value.then(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="reject-1"><a href="#reject-1" class="headerlink" title="reject"></a>reject</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     reject(value);</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<h4 id="all"><a href="#all" class="headerlink" title="all"></a>all</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> values = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">reslove, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      promises.forEach(<span class="function">(<span class="params">promise</span>) =&gt;</span> &#123;</span><br><span class="line">        promise.then(</span><br><span class="line">          (value) =&gt; &#123;</span><br><span class="line">            values.push(value);</span><br><span class="line">            <span class="keyword">if</span> (values.length == promises.length) &#123;</span><br><span class="line">              resolve(values);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          (reason) =&gt; reject(reason)</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h4 id="race"><a href="#race" class="headerlink" title="race"></a>race</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      promises.forEach(<span class="function">(<span class="params">promise</span>) =&gt;</span> &#123;</span><br><span class="line">        promise.then(</span><br><span class="line">          (value) =&gt; &#123;</span><br><span class="line">            resolve(value);</span><br><span class="line">          &#125;,</span><br><span class="line">          (reason) =&gt; &#123;</span><br><span class="line">            resolve(reason);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="和并起来的Promise如下面所示"><a href="#和并起来的Promise如下面所示" class="headerlink" title="和并起来的Promise如下面所示"></a>和并起来的Promise如下面所示</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="keyword">static</span> FUFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">  <span class="keyword">static</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">exector</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.status = <span class="built_in">Promise</span>.PENDING;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.callbacks = [];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      exector(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>),<span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="built_in">this</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="built_in">Promise</span>.PENDING) &#123;</span><br><span class="line">      <span class="built_in">this</span>.status = <span class="built_in">Promise</span>.FUFILLED;</span><br><span class="line">      <span class="built_in">this</span>.value = value</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.callbacks.map(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">          callback.onFulfilled(value)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">reject</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="built_in">Promise</span>.PENDING) &#123;</span><br><span class="line">      <span class="built_in">this</span>.status = <span class="built_in">Promise</span>.REJECTED;</span><br><span class="line">      <span class="built_in">this</span>.value = value</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.callbacks.map(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">          callback.onRejected(value)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> onFulfilled != <span class="string">&#x27;function&#x27;</span>) onFulfilled =  <span class="function">()=&gt;</span><span class="built_in">this</span>.value</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> onRejected != <span class="string">&#x27;function&#x27;</span>) onRejected =  <span class="function">()=&gt;</span><span class="built_in">this</span>.value</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="built_in">Promise</span>.PENDING) &#123;</span><br><span class="line">        <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">          onFulfilled: <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.parse(p,onFulfilled(value),resolve,reject)</span><br><span class="line">          &#125;,</span><br><span class="line">          onRejected: <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.parse(p,onRejected(value),resolve,reject)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="built_in">Promise</span>.FUFILLED) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.parse(p,onFulfilled(<span class="built_in">this</span>.value),resolve,reject)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="built_in">Promise</span>.REJECTED) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.parse(p,onRejected(<span class="built_in">this</span>.value),resolve,reject)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">parse</span>(<span class="params">p,result,resolve,reject</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == result) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Chaining cycle detected&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          result.then(resolve,reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(result)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Promsie) &#123;</span><br><span class="line">        value.then(resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">valye</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> values = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve， reject</span>)=&gt;</span> &#123;</span><br><span class="line">      promises.map(<span class="function">(<span class="params">promise</span>) =&gt;</span> &#123;</span><br><span class="line">        promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">          values.push(value);</span><br><span class="line">          <span class="keyword">if</span> (values.length == promises.length) &#123;</span><br><span class="line">            <span class="built_in">this</span>.resolve(values)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="function"><span class="params">resason</span> =&gt;</span> &#123;</span><br><span class="line">          reject(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promises</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      promises.map(<span class="function"><span class="params">promise</span> =&gt;</span> &#123;</span><br><span class="line">        promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">          resolve(value)</span><br><span class="line">        &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            reject(reason)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype._call = <span class="function"><span class="keyword">function</span>(<span class="params">obj,...args</span>)</span>&#123;</span><br><span class="line">    obj.fn = <span class="built_in">this</span>;</span><br><span class="line">    obj.fn(...args);</span><br><span class="line">    <span class="keyword">delete</span> obj.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">obj,args</span>)</span>&#123;</span><br><span class="line">    obj.fn = <span class="built_in">this</span>;</span><br><span class="line">    obj.fn(...args);</span><br><span class="line">    <span class="keyword">delete</span> obj.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JS方法函数的实现</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3学习笔记_基础01</title>
    <url>/2021/01/26/Vue%E5%9F%BA%E7%A1%8001/</url>
    <content><![CDATA[<h1 id="Vue3学习笔记-基础01"><a href="#Vue3学习笔记-基础01" class="headerlink" title="Vue3学习笔记_基础01"></a>Vue3学习笔记_基础01</h1><h2 id="Vue3比Vue2好在哪里？"><a href="#Vue3比Vue2好在哪里？" class="headerlink" title="Vue3比Vue2好在哪里？"></a>Vue3比Vue2好在哪里？</h2><ol>
<li><p>Tree shaking的优化</p>
</li>
<li><p>Typescript的支持</p>
</li>
<li><p>Custom Render API 的暴露 ：可以自定义渲染函数</p>
</li>
<li><p>diff算法的优化：Vue2全量对比，但Vue3为可能发生的元素加上了flag标识，在对比时只对比有标识的元素</p>
</li>
<li><p>静态提升：相同的变量在Vue2中每次都会重复的创建，但在V3中，相同的变量只有在第一次时创建，以后直接使用</p>
</li>
<li><p>事件侦听器缓存 ：V2中事件也是同变量一样绑定的，但是事件是一个不需要变的东西，所以V3将事件缓存，下一次直接调用</p>
</li>
<li><p>ssr渲染</p>
</li>
</ol>
<h2 id="composition-API"><a href="#composition-API" class="headerlink" title="composition API"></a>composition API</h2><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p>setup可接收2个参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">proprs,contextt</span>)</span>&#123;</span><br><span class="line">	props是一个对象，该对象包含了父级组件向子级组件传递的数据，并且是子级组件中使用props接收到的所有属性</span><br><span class="line">    &#123;attrs,emit,solts&#125; = context</span><br><span class="line">    context 也是一个对象：</span><br><span class="line">    		attrs --获取当前组件上的属性，但该属性是未在props上声明的属性</span><br><span class="line">            emit 分发事件</span><br><span class="line">            solts 插槽</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">emitFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      context.emit(<span class="string">&#x27;fatherFn&#x27;</span>, param)</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        emitFn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ref，shallowRef，reactive，shallowReactive"><a href="#ref，shallowRef，reactive，shallowReactive" class="headerlink" title="ref，shallowRef，reactive，shallowReactive"></a>ref，shallowRef，reactive，shallowReactive</h3><p>这里把他们4个放在一起，是因为他们都是用来创建响应式的数据的</p>
<p><strong>ref，shallowRef</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ref,shallowRef&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">const</span> preson1  =ref(&#123;</span><br><span class="line">    name:<span class="string">&#x27;keaiw1&#x27;</span>,</span><br><span class="line">    hobby:&#123;</span><br><span class="line">        one: <span class="string">&#x27;car1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> preson2  =shallowRef(&#123;</span><br><span class="line">    name:<span class="string">&#x27;keaiw2&#x27;</span>,</span><br><span class="line">    hobby:&#123;</span><br><span class="line">        one: <span class="string">&#x27;car2&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myclick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        person2.value.name = <span class="string">&#x27;KAW&#x27;</span></span><br><span class="line">        person2.value.hobby.one = <span class="string">&#x27;cat&#x27;</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;试图改变person2&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(person2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到count被包装成了RefImpl对象，count的值在该对象的value中，。在传入对象时(person1)会调用reactive方法，将value的值包装成一个Proxy。在模板中，不用count.value读取count的值，因为在模板解析时Vue已经帮我们做过了<br><img src="https://img-blog.csdnimg.cn/20210124205341537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzUzNTAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>shallowRef该方法同ref一样，但是不是深度ref包装,所以当我去点击那个按钮时，视图并未发生改变，但是内存中的值已经改变了<br><img src="https://img-blog.csdnimg.cn/20210124205358941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzUzNTAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>所以shallowRef其实监听的是person2.value的改变</p>
<p>在Vue2中ref还有取html元素的作用，那应该怎么取呢？在html中写的时候和Vue2中的写法一样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> box = ref(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    box</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>Reactiv，shallowReactive</strong>:</p>
<p>这两个和ref的区别就是会将对象包装成一个Proxy，其余没什么不同</p>
<p>reactive用于基本数据类型以外的其他数据类型，会将对象包装成Proxy</p>
<p><img src="https://img-blog.csdnimg.cn/20210124205421400.png" alt="在这里插入图片描述"></p>
<h3 id="toRaw"><a href="#toRaw" class="headerlink" title="toRaw"></a>toRaw</h3><p>故名思意 toRaw去生，就是通过响应式数据拿到原始数据来验证一下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> countNum = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> object = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> count = ref(countNum)</span><br><span class="line"><span class="keyword">const</span> obj = reactive(object)</span><br><span class="line"><span class="keyword">let</span> countRaw = toRaw(count.value)</span><br><span class="line"><span class="keyword">let</span> objRaw = toRaw(object)</span><br><span class="line"><span class="built_in">console</span>.log(countRaw === countNum);  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(object === objRaw);     <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是我在还原ref数据时，我用了<strong>count.value</strong></p>
<h3 id="markRaw"><a href="#markRaw" class="headerlink" title="markRaw"></a>markRaw</h3><p>当给对象做上标记时，他就再也不能变成响应式对象了，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">let</span> object = &#123;</span><br><span class="line">      name:<span class="string">&#x27;keaiw&#x27;</span>,</span><br><span class="line">      hobby:&#123;</span><br><span class="line">        one:[<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;c++&#x27;</span>,<span class="string">&#x27;js&#x27;</span>],</span><br><span class="line">        two:&#123;</span><br><span class="line">          gender:<span class="string">&#x27;female&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">let</span> obj = markRaw(object)</span><br><span class="line"><span class="keyword">let</span> state = reactive(obj)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      state.name = <span class="string">&#x27;KAW&#x27;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;我运行了&#x27;</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210124205445769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzUzNTAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>可以看到多了一个私有的属性__v_skip,当我点击按钮时，视图并未改变，</p>
<h3 id="toRef，toRefs"><a href="#toRef，toRefs" class="headerlink" title="toRef，toRefs"></a>toRef，toRefs</h3><p>利用toRef将对象中的某个属性变成响应式数据，修改响应式数据会影响原始的数据，但修改响应式数据不会引起视图的更新</p>
<p><img src="https://img-blog.csdnimg.cn/2021012420550041.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzUzNTAw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>toRefs会将对象中的每一项属性遍历变成响应式数据，改变数据后也不会引起视图的更新！</p>
<h3 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h3><p>自定义Ref</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myRef</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> customRef(<span class="function">(<span class="params">track,trigger</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                track()<span class="comment">//追踪数据</span></span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">                trigger() <span class="comment">//触发视图更新</span></span><br><span class="line">                <span class="keyword">return</span> newValue+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = myRef(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>如上我自定义了一个ref，该ref设置时，会自动设置他的值+1；</p>
<p>track ：告诉Vue这个值需要被追踪</p>
<p>triggle：告诉Vue视图该更新了</p>
<p>应用：发送网络请求。让setup函数中的代码看起来还是和同步代码一样</p>
<h3 id="readonly，shallowReadonly"><a href="#readonly，shallowReadonly" class="headerlink" title="readonly，shallowReadonly"></a>readonly，shallowReadonly</h3><p>同样看名字就知道这个API是干嘛的—只读</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> state = readonly(&#123;</span><br><span class="line">    name:<span class="string">&#x27;keaiw&#x27;</span>,</span><br><span class="line">    age:<span class="number">20</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样创建出的state就是只读的，不可修改 （深度只读）</p>
<p>shallowReadonly 创建的只读数据只是浅只读的</p>
<p>注意const创建的数据是不可修改的，和只读还是有一定的区别</p>
<h3 id="Provide-Inject"><a href="#Provide-Inject" class="headerlink" title="Provide / Inject"></a>Provide / Inject</h3><p>用于祖孙组件之间的传值</p>
<p>祖先组件中    provide(‘标识’, 变量)</p>
<p>孙子组件中        let data = inject(‘标识’) –用data接收来自祖先组件的数据</p>
<h2 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h2><ul>
<li>isRef: 检查一个值是否为一个 ref 对象</li>
<li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li>
<li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li>
<li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li>
</ul>
<h2 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h2><p>Vue2的周期钩子前面加上 “on” 来访问组件的生命周期钩子。</p>
<p>setup函数是在beforeCreate函数之前执行的，Vue3中不再需要beforeCreate，created</p>
<table>
<thead>
<tr>
<th align="center">Vue2</th>
<th align="center">Vue3</th>
</tr>
</thead>
<tbody><tr>
<td align="center">beforeCreate</td>
<td align="center">Not needed*</td>
</tr>
<tr>
<td align="center">created</td>
<td align="center">Not needed*</td>
</tr>
<tr>
<td align="center">beforeMount</td>
<td align="center">onBeforeMount</td>
</tr>
<tr>
<td align="center">mounted</td>
<td align="center">onMounted</td>
</tr>
<tr>
<td align="center">beforeUpdate</td>
<td align="center">onBeforeUpdate</td>
</tr>
<tr>
<td align="center">updated</td>
<td align="center">onUpdated</td>
</tr>
<tr>
<td align="center">beforeUnmount (beforeDestory )</td>
<td align="center">onBeforeUnmount</td>
</tr>
<tr>
<td align="center">unmounted(destoried)</td>
<td align="center">onUnmounted</td>
</tr>
</tbody></table>
<h2 id="watch-computed"><a href="#watch-computed" class="headerlink" title="watch/computed"></a>watch/computed</h2><p>在Vue2中所有的计算属性/监视是写在computed/watch函数里面的，但在V3中他们会返回一个对象</p>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> plusOne = computed(<span class="function">() =&gt;</span> count.value + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(plusOne.value) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">plusOne.value++ <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>当参数为一个回调函数时，该回调函数作为该属性的getter，所以在设置值时会报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> plusOne = computed(&#123;</span><br><span class="line">  get: <span class="function">() =&gt;</span> count.value + <span class="number">1</span>,</span><br><span class="line">  set: <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    count.value = val - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">plusOne.value = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>当参数为一个对象时，就可以写上get和set函数</p>
<h3 id="watch-watchEffect"><a href="#watch-watchEffect" class="headerlink" title="watch/watchEffect"></a>watch/watchEffect</h3><ul>
<li>监视指定的一个或多个响应式数据, 一旦数据变化, 就自动执行监视回调</li>
<li>默认初始时不执行回调, 但可以通过配置immediate为true, 来指定初始时立即执行第一次</li>
<li>通过配置deep为true, 来指定深度监视</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">如果监听的时reactive里面的数据则要通过函数指定，如果是ref或者reactive则直接指定</span><br><span class="line"><span class="comment">//监听一个数据</span></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123;<span class="attr">name</span>:<span class="string">&#x27;keaiw&#x27;</span>&#125;)</span><br><span class="line">cosnt count = ref(<span class="number">10</span>)</span><br><span class="line">watch(count,<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;监听一个数据且是ref类型，直接指定&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">watch(<span class="function">()=&gt;</span>state.name,<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;监听一个数据且是reactive类型的属性，通过函数指定&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//监听多个数据 通过数组指定</span></span><br><span class="line">watch([count,<span class="function">()=&gt;</span>state.name],<span class="function">(<span class="params">values</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;监听多个数据 通过数组指定&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="手写一些API"><a href="#手写一些API" class="headerlink" title="手写一些API"></a>手写一些API</h2><h3 id="shallowRef，shallowReactive"><a href="#shallowRef，shallowReactive" class="headerlink" title="shallowRef，shallowReactive"></a>shallowRef，shallowReactive</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowReactive</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,&#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params">target,prop</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target,prop)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">target,prop,newValue</span>)</span>&#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target,prop,newValue)</span><br><span class="line">    	&#125;,</span><br><span class="line">    	<span class="function"><span class="title">deleteProperty</span>(<span class="params">target,prop</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(target,prop)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowRef</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> shallowReactive(&#123;<span class="attr">value</span>:val&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="reactive，ref"><a href="#reactive，ref" class="headerlink" title="reactive，ref"></a>reactive，ref</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target)) &#123;</span><br><span class="line">      target.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        target[index] = reactive(item);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">Object</span>.keys(target).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        target[key] = reactive(target[key]);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">set</span>(<span class="params">obj, prop, newValue</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, prop, newValue);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">deleteProperty</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(target, prop);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ref</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reactive(&#123;<span class="attr">value</span>:target&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="readonly，shallowReadonly-1"><a href="#readonly，shallowReadonly-1" class="headerlink" title="readonly，shallowReadonly"></a>readonly，shallowReadonly</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowReadonly</span>(<span class="params">traget</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,&#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params">target, prop</span>)</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        	<span class="built_in">console</span>.log(<span class="string">&#x27;不能赋值&#x27;</span>)</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target)) &#123;</span><br><span class="line">      target.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        target[index] = reactive(item);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">Object</span>.keys(target).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        target[key] = reactive(target[key]);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">set</span>(<span class="params">obj, prop, newValue</span>)</span> &#123;</span><br><span class="line">    	 <span class="built_in">console</span>.log(<span class="string">&#x27;不能赋值&#x27;</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">deleteProperty</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(target, prop);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>-Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue核心之虚拟DOM与Diff算法</title>
    <url>/2021/02/02/Vue%E6%A0%B8%E5%BF%83%E4%B9%8B%E8%99%9A%E6%8B%9FDOM%E4%B8%8EDiff%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Vue核心之虚拟DOM与Diff算法"><a href="#Vue核心之虚拟DOM与Diff算法" class="headerlink" title="Vue核心之虚拟DOM与Diff算法"></a>Vue核心之虚拟DOM与Diff算法</h1><p>概述 :</p>
<p>虚拟Dom就是用一个对象来模拟真实对象的结构。</p>
<p>diff算法来查找当前层级的节点有什么不同，查找出不同来更新他</p>
<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p>虚拟的DOM具备5个属性分别是：</p>
<ul>
<li>sel 选择器</li>
<li>data 属性和key</li>
<li>children 子节点</li>
<li>text 节点中的文字</li>
<li>elm 对应的真实DOM</li>
<li>key 唯一的身份标识</li>
</ul>
<a id="more"></a>

<h3 id="真实DOM"><a href="#真实DOM" class="headerlink" title="真实DOM"></a>真实DOM</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">section</span>&gt;</span>    </span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="虚拟DOM-1"><a href="#虚拟DOM-1" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不妨你自己来试一试？</span></span><br></pre></td></tr></table></figure>
<h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h2><p>这里说下一个简易版的diff算法实现</p>
<p>首先大概介绍下所用到的函数及其功能</p>
<ol>
<li>h(<em>sel</em>, <em>data</em>, <em>children</em>) h函数接收1-3个参数，sel为必写参数返回Vnode函数</li>
<li>vnode 将传入的数据整合成虚拟的DOM返回</li>
<li>patch函数 实现diff算法的操作</li>
<li>patchVnode函数 细分各种情况达到diff的功能</li>
<li>createElement 将虚拟节点转化成真实的DOM节点</li>
<li>updateChildren diff的灵魂之处</li>
</ol>
<p>下面逐一介绍各个函数的实现</p>
<p>h函数我们知道可以传1-3个参数，所以为了实现函数的重载，就要先判断传入参数的数量和类型，区分出你到第二个参数底传的是data, 还是children。</p>
<h3 id="h"><a href="#h" class="headerlink" title="h"></a>h</h3><p>我这个h函数只是简易版的实现，没有children时请不要传[ ],且还有其他意想不到的传参错误，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">sel, data, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> children === <span class="string">&quot;string&quot;</span> || <span class="keyword">typeof</span> children === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// h(sel,&#123;&#125;,text)</span></span><br><span class="line">      <span class="keyword">return</span> vnode(sel, data, <span class="literal">undefined</span>, children, <span class="literal">undefined</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">      <span class="comment">// h(sel,&#123;&#125;,[h(),h()])</span></span><br><span class="line">        <span class="comment">// Array.isArray(children)</span></span><br><span class="line">      <span class="keyword">let</span> arr = [];</span><br><span class="line">      children.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(<span class="keyword">typeof</span> item === <span class="string">&quot;object&quot;</span> &amp;&amp; item.hasOwnProperty(<span class="string">&quot;sel&quot;</span>))) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;children 参数错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        arr.push(item);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> vnode(sel, data, arr, <span class="literal">undefined</span>, <span class="literal">undefined</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> children === <span class="string">&quot;object&quot;</span> &amp;&amp; children.hasOwnProperty(<span class="string">&quot;sel&quot;</span>)) &#123;</span><br><span class="line">      <span class="comment">// h(sel,&#123;&#125;,h())</span></span><br><span class="line">      <span class="keyword">return</span> vnode(sel, data,[children], <span class="literal">undefined</span>, <span class="literal">undefined</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;参数错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// h(sel,text)</span></span><br><span class="line">        <span class="keyword">return</span> vnode(sel, &#123;&#125;, <span class="literal">undefined</span>, data, <span class="literal">undefined</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(data)) &#123;</span><br><span class="line">      <span class="comment">// h(sel,[h(),h()])</span></span><br><span class="line">      <span class="keyword">let</span> arr = [];</span><br><span class="line">      data.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(<span class="keyword">typeof</span> item == <span class="string">&quot;object&quot;</span> &amp;&amp; item.hasOwnProperty(<span class="string">&quot;sel&quot;</span>))) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;children 参数错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        arr.push(item);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> vnode(sel, &#123;&#125;, arr, <span class="literal">undefined</span>, <span class="literal">undefined</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">&quot;object&quot;</span> &amp;&amp; data.hasOwnProperty(<span class="string">&quot;sel&quot;</span>)) &#123;</span><br><span class="line">      <span class="comment">// h(sel,h())</span></span><br><span class="line">      <span class="keyword">return</span> vnode(sel, &#123;&#125;, [data], <span class="literal">undefined</span>, <span class="literal">undefined</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;参数错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// h(sel)</span></span><br><span class="line">    <span class="keyword">return</span> vnode(sel, &#123;&#125;,<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;参数错误&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Vnode"><a href="#Vnode" class="headerlink" title="Vnode"></a>Vnode</h3><p>刚开始就说h函数返回的是Vnode函数，从上面的代码也可以得到验证</p>
<p>所以我直接贴出Vnode函数得代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">sel, data, children, text, elm</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> key = data.key||<span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">return</span> &#123;sel, data, children, text, elm, key&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我多嘴下snabbdom中data的参数是这个样子的：<code>data:&#123;props:&#123;href:&#39;http://tianhw.tk&#39;&#125;,key:&#39;A&#39;&#125;</code></p>
<h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h3><p>接下来看一看createElement函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> domNode = <span class="built_in">document</span>.createElement(vnode.sel);</span><br><span class="line">  vnode.elm = domNode;</span><br><span class="line">  <span class="keyword">if</span> (vnode.text != <span class="string">&quot;&quot;</span> &amp;&amp; vnode.children == <span class="literal">undefined</span>) &#123;</span><br><span class="line">    domNode.innerText = vnode.text;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(vnode.children) &amp;&amp; vnode.children.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      vnode.children.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//   console.log(item);</span></span><br><span class="line">          <span class="keyword">let</span> elm = createElement(item)</span><br><span class="line">          <span class="built_in">console</span>.log(domNode);</span><br><span class="line">          domNode.appendChild(elm)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> domNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟据sel创建出节点（真实DOM），我的代码是基于有children就没有text的</p>
<p>并将虚拟节点的elm属性赋值为真实的DOM</p>
<p>所以如果节点的text有则直接赋值，</p>
<p>如果有children就将children逐个遍历创建出真实的DOM再把子DOM追加到父DOM上，最后返回父DOM</p>
<h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>接下来就是patch函数了，我画个流程图来说明下patch函数的执行过程</p>
<p><img src="https://i.loli.net/2021/02/26/FX9c87DyYuaS5wW.png" alt="patch"></p>
<p>这里就不用我说什么了流程图很清楚，我也直接把代码贴上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> createElement <span class="keyword">from</span> <span class="string">&quot;./createElement&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> vnode <span class="keyword">from</span> <span class="string">&quot;./vnode&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> patchVnode <span class="keyword">from</span> <span class="string">&quot;./patchVnode&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">oldVnode, newVnode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (oldVnode.sel == <span class="string">&quot;&quot;</span> || oldVnode.sel == <span class="literal">undefined</span>) &#123;</span><br><span class="line">    oldVnode = vnode(</span><br><span class="line">      oldVnode.tagName.toLowerCase(),</span><br><span class="line">      &#123;&#125;,</span><br><span class="line">      <span class="literal">undefined</span>,</span><br><span class="line">      <span class="literal">undefined</span>,</span><br><span class="line">      oldVnode</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (oldVnode.key == newVnode.key &amp;&amp; oldVnode.sel == newVnode.sel) &#123;</span><br><span class="line">    <span class="comment">//是同一个节点</span></span><br><span class="line">    patchVnode(oldVnode, newVnode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> elm = createElement(newVnode);</span><br><span class="line">    <span class="keyword">if</span> (oldVnode.elm.parentNode &amp;&amp; elm) &#123;</span><br><span class="line">      oldVnode.elm.parentNode.insertBefore(elm, oldVnode.elm);</span><br><span class="line">    &#125;</span><br><span class="line">    oldVnode.elm.parentNode.removeChild(oldVnode.elm);</span><br><span class="line">    <span class="comment">//插入新的删除旧的</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h3><p>接下来就是patchVnode函数了，该函数就是细分diff算法的情况，我同样的画上一个流程图，帮助理解</p>
<p><img src="https://i.loli.net/2021/02/26/Y9VjLIFBcy52Nl4.png" alt="patchVnode"></p>
<h3 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h3><p>这个函数可以说是整个Diff的核心了，他处理的就是当老节点有children时，新节点也有children，这就设计增加删除等操作，</p>
<p>diff的核心就是同一节点不会重复创建，只会更新内容</p>
<p>updateChildren严格按照 下面这个顺序</p>
<ol>
<li><p>新前 == 旧前</p>
</li>
<li><p>新后 == 旧后</p>
</li>
<li><p>新后 == 旧前</p>
</li>
<li><p>新前 == 旧后</p>
</li>
</ol>
<p>这新前旧前这些东西都是指针，如图</p>
<p><img src="https://i.loli.net/2021/02/26/GtwhQ2b79rMI5P3.png" alt="指针"></p>
<p>接下来说几个重要的规则</p>
<p>命中一个条件后，就不会再进去下一个条件，循环条件为<code>*newStartIdx* &lt;= newEndIdx &amp;&amp; oldStartIdx &lt;= oldEndIdx</code>,</p>
<p>由于3，4命中条件后要对相关节点进行移动位置，所以当前位置是处理过的就要把他置为空，所以在进入循环前，要先判空，若为空，则指针移动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;判断指针是不是移动到null上，移动到则跳过到下一个节点</span><br><span class="line">if (oldStartVnode &#x3D;&#x3D; null) &#123; </span><br><span class="line">    oldStartVnode &#x3D; oldVnodeCh[++oldStartIdx]</span><br><span class="line">&#125; else if (oldEndVnode &#x3D;&#x3D; null) &#123;</span><br><span class="line">    oldEndVnode &#x3D; oldVnodeCh[--oldEndIdx]</span><br><span class="line">&#125; else if (newStartVnode &#x3D;&#x3D; null) &#123;</span><br><span class="line">    newStartVnode &#x3D; newVnodeCh[++newStartIdx]</span><br><span class="line">&#125;  else if (newEndVnode &#x3D;&#x3D; null) &#123;</span><br><span class="line">    newEndVnode &#x3D; newVnodeCh[--newEndIdx]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3规则命中 ，移动新后指向的节点到旧后的后面   <em>新后 == 旧前</em></p>
<p>4规则命中 ，移动新前指向的节点到旧前的前面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (same(oldStartVnode,newEndVnode)) &#123;</span><br><span class="line">            <span class="comment">//3. 新后 == 旧前</span></span><br><span class="line">            patchVnode(oldStartVnode, newEndVnode)</span><br><span class="line">            <span class="comment">// 移动新前到旧后的后面</span></span><br><span class="line">            parentElm.insertBefore(oldStartVnode.elm,oldEndVnode.elm.nextSibling)</span><br><span class="line">            oldStartVnode = oldVnodeCh[++oldStartIdx]</span><br><span class="line">            newEndVnode = newVnodeCh[--newEndIdx]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (same(oldEndVnode,newStartVnode)) &#123;</span><br><span class="line">            <span class="comment">// 4. 新前 == 旧后</span></span><br><span class="line">            patchVnode(oldEndVnode,newStartVnode)</span><br><span class="line">            parentElm.insertBefore(oldEndVnode, oldStartVnode.elm)</span><br><span class="line">            <span class="comment">//移动新前到旧前的前面</span></span><br><span class="line">            oldEndVnode = oldVnodeCh[--oldEndIdx]</span><br><span class="line">         </span><br></pre></td></tr></table></figure>




<p>若4个规则都未命中，则循环查找新前指向的节点，在旧的未处理节点中找到后，或者未找到，将该节点插入到旧前之前并设置为null（旧中的节点设置为null）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!keyMap) &#123;</span><br><span class="line">        keyMap = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = oldStartIdx; i &lt; oldEndIdx; i++) &#123;</span><br><span class="line">          <span class="keyword">let</span> key = oldVnodeCh[i].key;</span><br><span class="line">          <span class="keyword">if</span> (key !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            keyMap[key] = i;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> idxInOld = keyMap[newStartVnode.key];</span><br><span class="line">      <span class="keyword">if</span> (idxInOld === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="comment">//条件成立，表示他为全新的节点</span></span><br><span class="line">        parentElm.insertBefore(createElement(newStartVnode), oldStartVnode.elm);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不是新节点，要移动</span></span><br><span class="line">        <span class="keyword">let</span> elmToMove = oldVnodeCh[idxInOld];</span><br><span class="line">        patchVnode(elmToMove, newStartVnode);</span><br><span class="line">        oldVnodeCh[idxInOld] = <span class="literal">null</span>;</span><br><span class="line">        parentElm.insertBefore(elmToMove.elm, oldStartVnode.elm);</span><br><span class="line">      &#125;</span><br><span class="line">      newStartVnode = newVnodeCh[++newStartIdx];</span><br><span class="line">       </span><br></pre></td></tr></table></figure>


<p>再说几个结论，</p>
<p>当旧节点未处理完时，说明该删除节点了</p>
<p>新节点未处理完时，该添加节点了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">        <span class="comment">//newVnode 还有剩余节点未处理，要把剩余的节点插入到oldStartIdx之前</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = newStartIdx; i &lt;= newEndIdx; i++)&#123;</span><br><span class="line">            parentElm.insertBefore(createElement(newVnodeCh[i],oldVnodeCh[oldStartVnode].elm))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldStartIdx &lt;= oldEndIdx) &#123;</span><br><span class="line">        <span class="comment">//要删除节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = oldStartIdx; i &lt;= oldEndIdx; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldVnodeCh[i]) &#123;</span><br><span class="line">                parentElm.removeChild(oldVnodeCh[i].elm);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>完整的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> createElement <span class="keyword">from</span> <span class="string">&quot;./createElement.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> patchVnode <span class="keyword">from</span> <span class="string">&quot;./patchVnode.js&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">same</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.sel == b.sel &amp;&amp; a.key == b.key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">updatedChildren</span>(<span class="params">parentElm, oldVnodeCh, newVnodeCh</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newStartIdx = <span class="number">0</span>,</span><br><span class="line">    newEndIdx = newVnodeCh.length - <span class="number">1</span>,</span><br><span class="line">    oldStartIdx = <span class="number">0</span>,</span><br><span class="line">    oldEndIdx = oldVnodeCh.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> newStartVnode = newVnodeCh[newStartIdx],</span><br><span class="line">    newEndVnode = newVnodeCh[newEndIdx],</span><br><span class="line">    oldStartVnode = oldVnodeCh[oldStartIdx],</span><br><span class="line">    oldEndVnode = oldVnodeCh[oldEndIdx];</span><br><span class="line">  <span class="keyword">let</span> keyMap = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (newStartIdx &lt;= newEndIdx &amp;&amp; oldStartIdx &lt;= oldEndIdx) &#123;</span><br><span class="line">    <span class="comment">//判断指针是不是移动到null上，移动到则跳过到下一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (oldStartVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">      oldStartVnode = oldVnodeCh[++oldStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">      oldEndVnode = oldVnodeCh[--oldEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">      newStartVnode = newVnodeCh[++newStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newEndVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">      newEndVnode = newVnodeCh[--newEndIdx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">            严格按照下面的顺序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            1. 新前 == 旧前</span></span><br><span class="line"><span class="comment">            2. 新后 == 旧后</span></span><br><span class="line"><span class="comment">            3. 新后 == 旧前</span></span><br><span class="line"><span class="comment">            4. 新前 == 旧后</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (same(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      <span class="comment">//1.新前 == 旧前</span></span><br><span class="line">      patchVnode(oldStartVnode, newStartVnode);</span><br><span class="line">      oldStartVnode = oldVnodeCh[++oldStartIdx];</span><br><span class="line">      newtartVnode = newVnodeCh[++newStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (same(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      <span class="comment">//2. 新后 == 旧后</span></span><br><span class="line">      patchVnode(oldEndVnode, newEndVnode);</span><br><span class="line">      oldEndVnode = oldVnodeCh[--oldEndIdx];</span><br><span class="line">      newEndVnode = newVnodeCh[--newEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (same(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">      <span class="comment">//3. 新后 == 旧前</span></span><br><span class="line">      patchVnode(oldStartVnode, newEndVnode);</span><br><span class="line">      <span class="comment">// 移动新前到旧后的后面</span></span><br><span class="line">      parentElm.insertBefore(oldStartVnode.elm, oldEndVnode.elm.nextSibling);</span><br><span class="line">      oldStartVnode = oldVnodeCh[++oldStartIdx];</span><br><span class="line">      newEndVnode = newVnodeCh[--newEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (same(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">      <span class="comment">// 4. 新前 == 旧后</span></span><br><span class="line">      patchVnode(oldEndVnode, newStartVnode);</span><br><span class="line">      parentElm.insertBefore(oldEndVnode, oldStartVnode.elm);</span><br><span class="line">      <span class="comment">//移动新前到旧前的前面</span></span><br><span class="line">      oldEndVnode = oldVnodeCh[--oldEndIdx];</span><br><span class="line">      newStartVnode = newVnodeCh[++newStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!keyMap) &#123;</span><br><span class="line">        keyMap = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = oldStartIdx; i &lt; oldEndIdx; i++) &#123;</span><br><span class="line">          <span class="keyword">let</span> key = oldVnodeCh[i].key;</span><br><span class="line">          <span class="keyword">if</span> (key !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            keyMap[key] = i;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> idxInOld = keyMap[newStartVnode.key];</span><br><span class="line">      <span class="keyword">if</span> (idxInOld === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="comment">//条件成立，表示他为全新的节点</span></span><br><span class="line">        parentElm.insertBefore(createElement(newStartVnode), oldStartVnode.elm);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不是新节点，要移动</span></span><br><span class="line">        <span class="keyword">let</span> elmToMove = oldVnodeCh[idxInOld];</span><br><span class="line">        patchVnode(elmToMove, newStartVnode);</span><br><span class="line">        oldVnodeCh[idxInOld] = <span class="literal">null</span>;</span><br><span class="line">        parentElm.insertBefore(elmToMove.elm, oldStartVnode.elm);</span><br><span class="line">      &#125;</span><br><span class="line">      newStartVnode = newVnodeCh[++newStartIdx];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">//newVnode 还有剩余节点未处理，要把剩余的节点插入到oldStartIdx之前</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = newStartIdx; i &lt;= newEndIdx; i++) &#123;</span><br><span class="line">      parentElm.insertBefore(</span><br><span class="line">        createElement(newVnodeCh[i], oldVnodeCh[oldStartVnode].elm)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldStartIdx &lt;= oldEndIdx) &#123;</span><br><span class="line">    <span class="comment">//要删除节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = oldStartIdx; i &lt;= oldEndIdx; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldVnodeCh[i]) &#123;</span><br><span class="line">        parentElm.removeChild(oldVnodeCh[i].elm);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结：大概简易版的diff就是这样了吧，还有细节未理解到位，例如3，4 命中插入节点那块，还有在旧节点中寻找新节点指针指向的节点。还需要继续的深入，下一步先看看模板渲染。明天总结基础的知识，遇到了简单的东西还需要查，就很难受。</p>
<p>前几天都在看剧，反正吧，剧真TM好看。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue核心</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue核心之响应式原理</title>
    <url>/2021/01/26/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Vue核心之响应式原理"><a href="#Vue核心之响应式原理" class="headerlink" title="Vue核心之响应式原理"></a>Vue核心之响应式原理</h1><h2 id="Vue2-x响应式原理"><a href="#Vue2-x响应式原理" class="headerlink" title="Vue2.x响应式原理"></a>Vue2.x响应式原理</h2><p>不熟悉Object点击直达链接–<a href="http://www.tianhw.tk/2021/01/26/Object_Function_Proxy_Promise_Array_String_RegExp/#more">Object</a>、</p>
<p>想必已经知道Vue2的响应式原理是<em>Object.defineProperty</em>,所以接下来我直接来说响应式原理的实现，如果你对这个方法还不清楚，你可以看这篇</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperties(obj,&#123;</span><br><span class="line">    prop1:&#123;</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">Newvalue</span>)</span>&#123;</span><br><span class="line">           <span class="comment">//dom操作 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> value</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>没错正如你所见，数据的双向绑定响应式说白了就是在设置值的时候同时操作Dom</p>
<a id="more"></a>

<p>下面我来做一个简单的计算器顺便说一下思路：给输入框添加input事件，在每次输入的时候更新数据，数据有自己的getter和setter，每次setter都会更改result的 innerText（操作DOM） 运算符按钮点击同样的思路</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;calculator&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;result&quot;</span>&gt;<span class="number">0</span>&lt;/div&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;input-group&quot;</span>&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;text&quot;</span> value=<span class="string">&quot;0&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;f-input&quot;</span>&gt;</span><br><span class="line">            &lt;br&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;text&quot;</span> value=<span class="string">&quot;0&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;s-input&quot;</span>&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;btn-group&quot;</span>&gt;</span><br><span class="line">            &lt;button data-field=<span class="string">&quot;plus&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;current&quot;</span>&gt;+&lt;/button&gt;</span><br><span class="line">            &lt;button data-field=<span class="string">&quot;minus&quot;</span>&gt;-&lt;/button&gt;</span><br><span class="line">            &lt;button data-field=<span class="string">&quot;mul&quot;</span>&gt;*&lt;/button&gt;</span><br><span class="line">            &lt;button data-field=<span class="string">&quot;div&quot;</span>&gt;<span class="regexp">/&lt;/</span>button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Algorithm</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">plus</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">minus</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">mul</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">div</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="keyword">extends</span> <span class="title">Algorithm</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="built_in">document</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.result = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.result&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.fInput = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.f-input&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.sInput = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.s-input&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.btnGroup = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.btn-group&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.btns = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;button&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.data = <span class="built_in">this</span>.defineData();  <span class="comment">//defineData函数返回的对象属性是getter和setter在每次设置的时候都会调用计算方法</span></span><br><span class="line">    <span class="built_in">this</span>.btnIdx = <span class="number">0</span>;   <span class="comment">//当前运算符的index</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">defineData</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> fInputNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> sInputNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> field = <span class="string">&quot;plus&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> _self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(data, &#123;</span><br><span class="line">      field: &#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> field;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">Newvalue</span>)</span> &#123;</span><br><span class="line">          field = Newvalue;</span><br><span class="line">          _self.calculate(fInputNum, sInputNum, field);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      sInputNum: &#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> sInputNum;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">Newvalue</span>)</span> &#123;</span><br><span class="line">          sInputNum = Newvalue;</span><br><span class="line">          _self.calculate(fInputNum, sInputNum, field);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      fInputNum: &#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> fInputNum;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">Newvalue</span>)</span> &#123;</span><br><span class="line">          fInputNum = Newvalue;</span><br><span class="line">          _self.calculate(fInputNum, sInputNum, field);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.bindEvent();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">bindEvent</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.btnGroup.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="built_in">this</span>.onFieldBtnClick.bind(<span class="built_in">this</span>));</span><br><span class="line">    <span class="built_in">this</span>.fInput.addEventListener(<span class="string">&quot;input&quot;</span>, <span class="built_in">this</span>.onNumberInput.bind(<span class="built_in">this</span>));  </span><br><span class="line">    <span class="built_in">this</span>.sInput.addEventListener(<span class="string">&quot;input&quot;</span>, <span class="built_in">this</span>.onNumberInput.bind(<span class="built_in">this</span>));</span><br><span class="line">        <span class="comment">//这里两个元素绑定的是同一个函数，函数里面用className区分是fInput还是sInput</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">onFieldBtnClick</span>(<span class="params">ev</span>)</span> &#123;  <span class="comment">//返回正在点击的元素</span></span><br><span class="line">    <span class="keyword">const</span> e = ev || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">let</span> tar = e.target || e.srcElement,</span><br><span class="line">      tagName = tar.tagName.toLowerCase();</span><br><span class="line">    tagName === <span class="string">&quot;button&quot;</span> &amp;&amp; <span class="built_in">this</span>.fieldUpdate(tar);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">fieldUpdate</span>(<span class="params">target</span>)</span> &#123;   更新运算符按钮颜色，并且取出当前运算符</span><br><span class="line">    <span class="built_in">this</span>.btns[<span class="built_in">this</span>.btnIdx].className = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.btnIdx = [].indexOf.call(<span class="built_in">this</span>.btns, target);</span><br><span class="line">    target.className += <span class="string">&quot;current&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.data.field = target.getAttribute(<span class="string">&quot;data-field&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">onNumberInput</span>(<span class="params">ev</span>)</span> &#123;  <span class="comment">//跟据当前正在输入的input，更新对应的inputNum</span></span><br><span class="line">    <span class="keyword">const</span> e = ev || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">let</span> tar = e.target || e.srcElement;</span><br><span class="line">    <span class="keyword">let</span> className = tar.className,</span><br><span class="line">      val = <span class="built_in">Number</span>(tar.value.replace(<span class="regexp">/\s+/g</span>, <span class="string">&quot;&quot;</span>)) || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (className) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;f-input&quot;</span>:</span><br><span class="line">        <span class="built_in">this</span>.data.fInputNum = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;s-input&quot;</span>: </span><br><span class="line">        <span class="built_in">this</span>.data.sInputNum = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">calculate</span>(<span class="params">fInputNum, sInputNum, field</span>)</span> &#123;   <span class="comment">//更新result里面的数字</span></span><br><span class="line">    <span class="built_in">this</span>.result.innerText = <span class="built_in">this</span>[field](fInputNum, sInputNum);  <span class="comment">//dom操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Calculator(<span class="built_in">document</span>).init();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结：在操作DOM时，我想不起来<code>const e = *ev* || window.event, tar = e.target || e.srcElement;</code>这些东西，我脑子里总是直接操作button这种想法，却忘了点击btn-group的同时，也就相当于点击button，当时学习DOM时也没有认真的学习，导致现在忘啥都忘了</p>
<h2 id="Vue3响应式原理"><a href="#Vue3响应式原理" class="headerlink" title="Vue3响应式原理"></a>Vue3响应式原理</h2><p>不熟悉Proxy点击直达链接–<a href="http://www.tianhw.tk/2021/01/26/Object_Function_Proxy_Promise_Array_String_RegExp/#more">Proxy</a>、</p>
<p>Vue3响应式原理核心Proxy</p>
<p>这里和上面的思路一样就是把defineData用Proxy换了，</p>
<p>注意：set里面我先赋值再更新result。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">defineData</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">      sInputNum: <span class="number">0</span>,</span><br><span class="line">      fInputNum: <span class="number">0</span>,</span><br><span class="line">      field: <span class="string">&quot;plus&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> _self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">      <span class="function"><span class="title">set</span>(<span class="params">tar, prop, newValue</span>)</span> &#123;</span><br><span class="line">        tar[prop] = newValue;</span><br><span class="line">        _self.calculate(tar.fInputNum, tar.sInputNum, tar.field);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(tar, prop, newValue);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params">tar, prop</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(tar, prop);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<p>参考：<a href="https://www.bilibili.com/video/BV1Dk4y127Ha">Bilibili—Vue响应式原理</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue核心</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器素养篇</title>
    <url>/2021/01/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%B4%A0%E5%85%BB%E7%AF%87/</url>
    <content><![CDATA[<h3 id="浏览器素养篇"><a href="#浏览器素养篇" class="headerlink" title="浏览器素养篇"></a>浏览器素养篇</h3><a id="more"></a>

<p>用户界面：<img src="https://img-blog.csdnimg.cn/2020102818481194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzUzNTAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>浏览器引擎：包含数据持久层——存放cookie等数据</p>
<p>渲染引擎：包含JS解析器，网络模块。渲染引擎通常也被称为内核</p>
<p>各浏览器内核：</p>
<table>
<thead>
<tr>
<th>浏览器名称</th>
<th>内核</th>
</tr>
</thead>
<tbody><tr>
<td>IE</td>
<td>Trident</td>
</tr>
<tr>
<td>Firefox</td>
<td>Gecko</td>
</tr>
<tr>
<td>Safari</td>
<td>Webkit</td>
</tr>
<tr>
<td>Chrome</td>
<td>Blink</td>
</tr>
<tr>
<td>Opera</td>
<td>Blink</td>
</tr>
<tr>
<td>Edge</td>
<td>Blink</td>
</tr>
</tbody></table>
<p>注：其中Blink内核是基于Webkit内核的。</p>
<p>在了解浏览器的工作原理之前，有必要知道进程和线程之间的关系和区别，</p>
<p>进程：是操作系统进行资源分配和调度的基本单元，可以申请和拥有计算机资源，进程是程序的基本执行实体</p>
<p>线程：操作系统能够进行运算和调度的最小单位，一个进程可以并发多个线程，每个线程并发执行不同的任务</p>
<p>进程之间传递信息通过通信管道IPC传递，同一进程下的线程可以共享数据</p>
<p>多进程的浏览器结构</p>
<p>浏览器进程：负责除标签页外的用户界面（前进后退，地址栏，书签）与浏览器的其他进程的协调工作</p>
<p>网络进程：负责发送接收网络请求</p>
<p>GPU进程：浏览器界面的渲染</p>
<p>插件进程：控制网站中所使用的插件，例如：flash插件（并发你所安装的拓展）</p>
<p>渲染器进程：控制tab下的所有内容的渲染</p>
<p>一般在默认情况下浏览器会为每个标签页都创建以上所有的进程，这和你安装浏览器所选择方式有关。</p>
<p>拿chrome来说吧：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>process-per-site-instance</td>
<td>不同站点同一站点的不同页面都会创建新的进程</td>
</tr>
<tr>
<td>process-per-site</td>
<td>同一站点使用相同的进程</td>
</tr>
<tr>
<td>process-per-tab</td>
<td>同一标签页使用同一进程</td>
</tr>
<tr>
<td>single-process</td>
<td>浏览器引擎和渲染引擎使用同意进程</td>
</tr>
</tbody></table>
<p>介绍完浏览器的基本内容后，那么当在地址栏中输入内容时会发生什么事情呢？</p>
<p>当输入内容后，浏览器进程的    UI线程会捕捉输入内容，如果不是一个正确的URL，就会启动浏览器的默认搜索引擎进行查询，如果是一个URL，所进行的事情是本篇文章重点要阐述的。</p>
<p><strong>前奏</strong></p>
<p>如果是URL，UI线程便会启动网络进程获取信息，信息获取完毕后，谷歌内部的安全检测系统<em>Safebrowsing</em>会对网站进行检测，如果是恶意网站，则会显示一个恶意网站的界面用来阻止你的访问。当这个站点没问题时，网络进程程通知UI线程已经OK了，这时，UI线程会创建渲染器进程来渲染页面。</p>
<p>浏览器进程通过IPC将数据传输给渲染器进程。</p>
<p><strong>它要开始了</strong></p>
<p>1.渲染器主线程解析HTML代码，构造Dom数据结构，首先通过<em>tokenniser</em>标记化通过词法分析将输入的HTML内容解析成多个标记，根据识别后的的标记进行<strong>Dom tree</strong> 的构造。</p>
<p>2.主线程通过解析CSS确定Dom节点的计算样式，接下来要知道节点应处于页面中的哪个位置，和节点所占据的大小，该阶段称之为layout布局。</p>
<p>3.主线程通过便利Dom和计算好的样式生产layout tree 该树上记录了节点的坐标和大小</p>
<p>4.接着便利layout tree 创建绘制记录表（paint record）产生layer tree 这个阶段称为绘制</p>
<p>所有东西准备完毕，接下来就要把内容渲染在页面上了！</p>
<p>5.信息确认完毕后，主线程将信息传递给合成器线程，合成器线程将每个图层切成小块发给栅格化线程，栅格化完毕后，将信息存在GPU中，合成器线程收集称为“draw quads”的图块信息，这些信息记录了图块在内存中的位置和在页面的哪个位置绘制图块的信息根据这些信息合成器线程生成合成器帧，</p>
<p>6.合成器帧通过ipc传输给浏览器进程，浏览器进程将合成器帧传输给GPU，GPU渲染到屏幕上，当页面变化时，会生成新的合成器帧重复以上步骤</p>
<p><strong>总结：</strong></p>
<p>主线程 ：DOM style layout paint layer</p>
<p><img src="https://img-blog.csdnimg.cn/20201028184907501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzUzNTAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>合成器线程：titles   frame</p>
<p>栅格线程：raster draw quads</p>
<p><img src="https://img-blog.csdnimg.cn/20201028184920648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NzUzNTAw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong><em>介绍几个概念</em></strong></p>
<p><strong>栅格化</strong>：将信息转化成为像素点的过程</p>
<p><strong>合成</strong>：将页面的各个部分分成多个图层分别对其栅格化，并在合成器线程中单独进行合成，页面中的所有元素按照某种规则进行分图层。</p>
<p><strong>重绘</strong>:某些元素的外观改变（颜色外观等改变）</p>
<p><strong>重排</strong>：重新生成布局，重新排列元素（大小改变）</p>
<p>重排会浪费性能，所以应该减少或避免重排</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack基础01</title>
    <url>/2021/01/26/webpack%E5%9F%BA%E7%A1%8001/</url>
    <content><![CDATA[<h3 id="webpack的基本使用及其配置"><a href="#webpack的基本使用及其配置" class="headerlink" title="webpack的基本使用及其配置"></a>webpack的基本使用及其配置</h3><p>前言：这学期总觉得忙忙碌碌，可仔细想想好像啥也都没学到，大大小小的知识点都接触了一点，可也好像只是只达到了解，前几天看了一个讲解Object对象上的方法的视频，突然发现那么多的细节都不知道，所以在今后的学习中要更加的注重细节<strong>学习切忌好高骛远</strong>。  </p>
<hr>
<h4 id="development："><a href="#development：" class="headerlink" title="development："></a>development：</h4><a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">webpack 输出打包内容</span></span><br><span class="line"><span class="comment">npx webapck-dev-server 在内存中打包编译</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;resolve&#125; = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">  optput: &#123;</span><br><span class="line">    filename: <span class="string">&quot;js/built.js&quot;</span>,</span><br><span class="line">    path: resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  modele: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">        options: &#123;</span><br><span class="line">          optputPath: <span class="string">&quot;mdeia&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">        options: &#123;</span><br><span class="line">          optputPath: <span class="string">&quot;mdeia&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">        loader: <span class="string">&quot;url-loader&quot;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          optputPath: <span class="string">&quot;mdeia&quot;</span>,</span><br><span class="line">          name: <span class="string">&quot;[hash:10].[ext]&quot;</span>,</span><br><span class="line">          limit: <span class="number">8</span> * <span class="number">1024</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.html$/</span>,</span><br><span class="line">        loader: <span class="string">&quot;html-loaer&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        exclude: <span class="regexp">/\.(js|html|css|less|png|jpg|gif)$/</span>,</span><br><span class="line">        loader: <span class="string">&quot;file-loader&quot;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">&quot;[hash:10].[ext]&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">&quot;./src/index/html&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  mode: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">    compress: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">3000</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Production"><a href="#Production" class="headerlink" title="Production"></a>Production</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产环境的配置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;resolve&#125; = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> OptimizeCssAssetsWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;optimize-css-assets-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line">process.env.NODE_ENV = <span class="string">&quot;development&quot;</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&quot;js/built.js&quot;</span>,</span><br><span class="line">    path: resolve(__dirname, <span class="string">&quot;build&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//下载 postcss-loader  postcss-preset-env</span></span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              indent: <span class="string">&quot;postcss&quot;</span>,</span><br><span class="line">              plugins: <span class="function">() =&gt;</span> [<span class="built_in">require</span>(<span class="string">&quot;postcss-preset-env&quot;</span>)()],</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//下载3个库eslint eslint-config-airbnb-base eslint-plugin-import eslint-loader</span></span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        enforce: <span class="string">&quot;pre&quot;</span>,</span><br><span class="line">        loader: <span class="string">&quot;eslint-loader&quot;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          fix: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        loader: <span class="string">&quot;bable-loader&quot;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [</span><br><span class="line">            <span class="string">&quot;@bable/preset-env&quot;</span>,</span><br><span class="line">            &#123;</span><br><span class="line">              useBuiltIns: <span class="string">&quot;usage&quot;</span>,</span><br><span class="line">              corejs: &#123;<span class="attr">version</span>: <span class="number">3</span>&#125;,</span><br><span class="line">              targets: &#123;</span><br><span class="line">                chrome: <span class="string">&quot;60&quot;</span>,</span><br><span class="line">                firefox: <span class="string">&quot;50&quot;</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpg|png|gif)/</span>,</span><br><span class="line">        loader: <span class="string">&quot;url-loader&quot;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: <span class="number">8</span> * <span class="number">1024</span>,</span><br><span class="line">          name: <span class="string">&quot;[hash:10].[ext]&quot;</span>,</span><br><span class="line">          outputPath: <span class="string">&quot;imgs&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.html$/</span>,</span><br><span class="line">        loader: <span class="string">&quot;html-loader&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        exclude: <span class="regexp">/\.(js|css|less|html|jpg|png|gif)$/</span>,</span><br><span class="line">        loader: <span class="string">&quot;file-loader&quot;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          outputPath: <span class="string">&quot;media&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">&quot;css/built.css&quot;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> OptimizeCssAssetsWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">&quot;./src/index.html&quot;</span>,</span><br><span class="line">      minify: &#123;</span><br><span class="line">        collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">        removeAttributeQuotes: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  mode: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>package.json</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;browserslist&quot;:&#123;</span><br><span class="line">  &quot;development&quot;:[</span><br><span class="line">    &quot;last 1 chrome version&quot;,</span><br><span class="line">    &quot;last 1 firefox version&quot;,</span><br><span class="line">    <span class="string">&quot;last 1 safari version&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  &quot;production&quot;:[</span><br><span class="line">    &quot;&gt;0.2%&quot;,</span><br><span class="line">    &quot;not dead&quot;,</span><br><span class="line">    <span class="string">&quot;not op_mini all&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">&quot;eslintConfig&quot;:&#123;</span><br><span class="line">  &quot;extends&quot; : &quot;airbnb-base&quot;,</span><br><span class="line">  &quot;env&quot;:&#123;</span><br><span class="line">    &quot;browser&quot;:true  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>上面的eslint采用的是airbnb这个库所定的规范</p>
<p>开发环境下写到的设置node环境变量，是因为默认兼容性处理是在生产环境下的，所以需要手动把环境调至开发环境</p>
<h3 id="生产及开发环境下的性能优化"><a href="#生产及开发环境下的性能优化" class="headerlink" title="生产及开发环境下的性能优化"></a>生产及开发环境下的性能优化</h3><h4 id="development"><a href="#development" class="headerlink" title="development"></a>development</h4><h4 id="production"><a href="#production" class="headerlink" title="production"></a>production</h4>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝、防抖、节流</title>
    <url>/2021/01/26/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E9%98%B2%E6%8A%96%E3%80%81%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h4 id="JavaScript-的深拷贝"><a href="#JavaScript-的深拷贝" class="headerlink" title="JavaScript 的深拷贝"></a>JavaScript 的深拷贝</h4><h5 id="DeepCloneOne"><a href="#DeepCloneOne" class="headerlink" title="DeepCloneOne:"></a><strong>DeepCloneOne:</strong></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCloneOne</span>(<span class="params">ori,tar</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">let</span> tar = tar||&#123;&#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> ori)&#123;</span><br><span class="line">       <span class="keyword">if</span>(ori.hasOwnProperty(key))&#123;</span><br><span class="line">           <span class="keyword">if</span>(<span class="keyword">typeof</span> ori[key] === <span class="string">&#x27;object&#x27;</span>&amp;&amp; ori[key]!==<span class="literal">null</span>)&#123;</span><br><span class="line">                tar[key] = <span class="built_in">Object</span>.prototype.toString.call(ori[k]) == <span class="string">&#x27;[object Array]&#x27;</span>?[]:&#123;&#125;</span><br><span class="line">                deepCloneOne(ori[key],tar[key])</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               tar[key] = ori[key]</span><br><span class="line">           &#125;</span><br><span class="line">          </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> tar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <a id="more"></a>

<p>第一版的深拷贝会出现什么问题呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;&#125;</span><br><span class="line">a.b = b</span><br><span class="line">b.a = a</span><br><span class="line">deepCloneOne(a);</span><br></pre></td></tr></table></figure>
<p><strong>问题1</strong>：跑上面的代码会出现死循环问题，为什么呢？b已经拷贝过了，但是b里又有a，a里又有b所以，第一个代码会无限的克隆下去，</p>
<p><strong>解决</strong>：正确的做法是记录下已经克隆过的属性，克隆过就不再克隆，使用WeakMap来记录属性是否已经拷贝过</p>
<p><strong>问题2</strong>：上面的深拷贝会出现<code>Date RegExp </code>这种特殊的引用值无法拷贝</p>
<p><strong>解决</strong>:判断是否为上面的特殊对象</p>
<h5 id="DeepCloneTwo"><a href="#DeepCloneTwo" class="headerlink" title="DeepCloneTwo:"></a><strong>DeepCloneTwo:</strong></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCloneTwo</span>(<span class="params">origin, hashMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">const</span> hashKey = hashMap.get(origin);</span><br><span class="line">          <span class="keyword">if</span>(origin == <span class="literal">undefined</span> ||<span class="keyword">typeof</span> origin!==<span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> origin;</span><br><span class="line">          <span class="keyword">if</span>(origin <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(origin)</span><br><span class="line">          <span class="keyword">if</span>(origin <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(origin)</span><br><span class="line">          <span class="keyword">if</span>(hashKey) <span class="keyword">return</span> hashKey</span><br><span class="line">          <span class="keyword">const</span> tar = <span class="keyword">new</span> origin.constructor();</span><br><span class="line">          hashMap.set(origin, tar)</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> origin) &#123;</span><br><span class="line">              <span class="keyword">if</span> (origin.hasOwnProperty(key)) &#123;</span><br><span class="line">                  tar[key] = deepCloneTwo(origin[key],hashMap)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> tar;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>为什么要使用weakmap而不使用map?</p>
<p>当键名不在时，他的内存会被自动的回收——————防止内存泄漏</p>
<h4 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay, immediately</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> debounced =  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (immediately) &#123;</span><br><span class="line">      <span class="keyword">let</span> callnow = !timer</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;,delay)</span><br><span class="line">      <span class="keyword">if</span> (callnow) &#123;</span><br><span class="line">        fn.apply(that,args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.apply(that,args)</span><br><span class="line">      &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  debounced.cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    timer = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> old = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().valueOf();</span><br><span class="line">    <span class="keyword">if</span> (options.leading == <span class="literal">false</span>) &#123;</span><br><span class="line">      old = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (now - old&gt;delay) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">      fn.apply(fn, args)</span><br><span class="line">      old = now</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!timer &amp;&amp; options.trailing!==<span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        old = <span class="keyword">new</span> <span class="built_in">Date</span>().valueOf()</span><br><span class="line">        fn.apply(that, args)</span><br><span class="line">        timer = <span class="literal">null</span></span><br><span class="line">      &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JS功能函数</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 基础01</title>
    <url>/2021/02/12/TypeScript-%E5%9F%BA%E7%A1%8001/</url>
    <content><![CDATA[<p>TypeScript 基础01</p>
]]></content>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Dynamic Programming_01</title>
    <url>/2021/03/03/Dynamic_Programming_01/</url>
    <content><![CDATA[<h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h1><h2 id="一"><a href="#一" class="headerlink" title="一."></a>一.</h2><p>题目：给定一个数组选出不相邻的数字，使得选出的数字和最大。</p>
<p>opt表示最优的解，每次只有选或者不选2种状态。</p>
<p>该题有2种出口：</p>
<ol>
<li>当只剩下1个数的时候（index ==0），最优解就是这个数。</li>
<li>当只剩下2个数的时候（index = 1），最优解为 max(arr[0],arr[1]])。</li>
</ol>
<p><img src="https://i.loli.net/2021/03/03/3PKlJsGuvODfA58.png" alt="Dynamic Programming (1)"></p>
<p>递归算法应该是非常的好写，自己尝试即可，下面给出非递归代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dpOpt</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> opt = <span class="keyword">new</span> <span class="built_in">Array</span>(arr.length).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> A,B;</span><br><span class="line">    opt[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    opt[<span class="number">1</span>] = <span class="built_in">Math</span>.max(arr[<span class="number">0</span>],arr[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        A = opt[i-<span class="number">2</span>]+opt[i];</span><br><span class="line">        B = opt[i-<span class="number">1</span>];</span><br><span class="line">        opt[i] = <span class="built_in">Math</span>.max(A,B)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> opt[opt.length-<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二"><a href="#二" class="headerlink" title="二."></a>二.</h2><p>题目：给出一个数组arr，和一个数num， 在数组中选出若干个数加起来和等于num，如果可以选出返回true否则返回false </p>
<p>注：题目中给出的数字都是正整数</p>
<p>subset表示选出的字迹。</p>
<p>该题有3种出口：</p>
<ol>
<li>sebset第二个参数为s==0</li>
<li>判断到arr[0] : arr[0]==s 返回true 否则返回false</li>
<li>当前arr[i]大于s : 执行不选逻辑 </li>
</ol>
<p><img src="https://i.loli.net/2021/03/03/mIfSysvHKb8rO6N.png" alt="Dynamic Programming"></p>
<p>写递归代码也很好写，这里介绍非递归的方法</p>
<p><strong>问题一</strong>：如何把中间子问题存储起来？</p>
<p><strong>问题二</strong>：怎么设计存储的数据结构？</p>
<p> 采用二维数组来保存中间子问题，行为原数组，列为s。</p>
<p>先将第一行填好，再去填第一列</p>
<p><img src="https://i.loli.net/2021/03/03/Ge8B9EmYFxkURSZ.png" alt="chart"></p>
<p>给出非递归代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deSubset</span>(<span class="params">arr, s</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> subset = [],</span><br><span class="line">        A,</span><br><span class="line">        B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        subset.push(<span class="keyword">new</span> <span class="built_in">Array</span>(s+<span class="number">1</span>).fill(<span class="number">0</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;s+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        subset[<span class="number">0</span>][i] = fasle  <span class="comment">//第0行设置为false</span></span><br><span class="line">    &#125;</span><br><span class="line">    subset[<span class="number">0</span>][<span class="number">1</span>] = <span class="literal">true</span>;  <span class="comment">//当arr[0] == s 时，返回true</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        subset[i][<span class="number">1</span>] = <span class="literal">true</span>;  <span class="comment">//当s == 0 时， 返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>;j&lt;s+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;j)&#123;   <span class="comment">//判断出口2</span></span><br><span class="line">                subset[i][j] = subset[i-<span class="number">1</span>][j]</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                A = subset[i-<span class="number">1</span>][j-arr[i]];</span><br><span class="line">                B = subset[i-<span class="number">1</span>][j]</span><br><span class="line">                subset[i][j] = A||B</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subset[arr.length-<span class="number">1</span>][s.length]  <span class="comment">//返回最后一个数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么不用递归?</p>
<p>递归会重复执行一些代码，例如在斐波那契中求  <code>f(7) = f(6) +f(5)   =( f(5)+f(4)) + f(5) </code>  直接看出f(5)求了2次。</p>
<p>上面两个问题的思路都是：</p>
<ol>
<li>从后往前看，选或者不选</li>
<li>寻找出口</li>
<li>思考子事件如何存储</li>
<li>编写代码</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码解析01-数据驱动</title>
    <url>/2021/03/09/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%9001-%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h2><h3 id="new-Vue-时发生了什么？"><a href="#new-Vue-时发生了什么？" class="headerlink" title="new Vue 时发生了什么？"></a>new Vue 时发生了什么？</h3><p>index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">    !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue)</span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure>
<p>可以看到向外暴露了Vue构造函数，并在Vue的prototype上混入一些实例方法。在new vue的时候执行_init方法初始化options</p>
<h3 id="Vue实例挂载"><a href="#Vue实例挂载" class="headerlink" title="Vue实例挂载"></a>Vue实例挂载</h3><p><code>src/platform/web/entry-runtime-with-compiler.js</code> 文件中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; query(el)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = <span class="built_in">this</span>.$options</span><br><span class="line">  <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">  <span class="keyword">if</span> (!options.render) &#123;</span><br><span class="line">    <span class="keyword">let</span> template = options.template</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">          template = idToTemplate(template)</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !template) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>,</span><br><span class="line">              <span class="built_in">this</span></span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</span><br><span class="line">        template = template.innerHTML</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">          warn(<span class="string">&#x27;invalid template option:&#x27;</span> + template, <span class="built_in">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">      template = getOuterHTML(el)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(<span class="string">&#x27;compile&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class="line">        outputSourceRange: process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        delimiters: options.delimiters,</span><br><span class="line">        comments: options.comments</span><br><span class="line">      &#125;, <span class="built_in">this</span>)</span><br><span class="line">      options.render = render</span><br><span class="line">      options.staticRenderFns = staticRenderFns</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(<span class="string">&#x27;compile end&#x27;</span>)</span><br><span class="line">        measure(<span class="string">`vue <span class="subst">$&#123;<span class="built_in">this</span>._name&#125;</span> compile`</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;compile end&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="built_in">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>首先缓存Vue原型上的<code>$mount</code>方法，然后重写原型上的<code>$mount</code>方法。</p>
<p>在<code>$mount</code>中先对<code>el</code>获取真实的dom节点，如果el是<code>body</code>或者<code>html</code>则抛出警告，Vue不允许节点挂载在<code>body</code>、<code>html</code>上</p>
<p>接着将实例的<code>options</code>拿出来，如果<code>options</code>里面没有<code>render</code>函数，如果没有再判断有没有<code>template</code>如果没有的话，将<code>*.vue</code>文件中的模板赋值给<code>template</code></p>
<p>执行<code>compileToFunctions</code>返回<code>render</code>函数并给<code>options</code>添加上<code>render</code></p>
<p>最后调用原型上的<code>$mount</code>方法挂载</p>
<p>$mount定义在<code>src/platform/web/runtime/index.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="built_in">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到实际上是调用了<code>mountComponent</code>方法,该方法定义在<code>src/core/instance/lifecycle.js</code>文件中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  el: ?Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  <span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> ((vm.$options.template &amp;&amp; vm.$options.template.charAt(<span class="number">0</span>) !== <span class="string">&#x27;#&#x27;</span>) ||</span><br><span class="line">        vm.$options.el || el) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">&#x27;You are using the runtime-only build of Vue where the template &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;compiler is not available. Either pre-compile the templates into &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;render functions, or use the compiler-included build.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">&#x27;Failed to mount component: template or render function not defined.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, <span class="string">&#x27;beforeMount&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher&#x27;s constructor</span></span><br><span class="line">  <span class="comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component&#x27;s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">        callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm._isMounted = <span class="literal">true</span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>可以看到<code>mountComponent</code>实例化了一个渲染<code>Watcher</code>并将<code>updateComponent</code>传入,<code>updateComponent</code>调用了<code>_update</code>方法,<code>_update</code>传入了<code>render</code>的执行结果–<code>Vnode</code></p>
<p><code>Watcher</code>有2个作用：</p>
<ul>
<li>初始化时执行<code>updateComponent</code></li>
<li>数据变化时执行<code>updateComponent</code></li>
</ul>
<p>注意：这里的vm.$vnode == null 表示当前是根Vue实例</p>
<h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>接上面，<code>_render</code>是实例的一个私有的方法返回的是<code>Vnode</code></p>
<p>该方法定义在<code>src/core/instance/render.js</code>中</p>
<p>这怎么把<code>template</code>编译成为<code>render</code>函数这里不再赘述，可以看我另一篇文章 <a href="http://www.tianhw.tk/2021/02/10/AST_render/">AST and Render</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vnode = render.call(vm._renderProxy, vm.$createElement)</span><br></pre></td></tr></table></figure>
<p>这里的<code>vm._renderProxy</code>指的就是<code>vm</code>实例</p>
<h3 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h3><p>为什么操作虚拟DOM而不直接操作真实DOM呢？</p>
<p>原因是真实DOM上的属性是很多的，生成一个真实的DOM远远比生成一个虚拟的DOM代价大的多。</p>
<p>什么是虚拟DOM?</p>
<p>就是用对象来描述DOM结构。</p>
<p>Vnode定义在<code>src/core/vdom/vnode.js</code>中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  tag: string | <span class="keyword">void</span>;</span><br><span class="line">  data: VNodeData | <span class="keyword">void</span>;</span><br><span class="line">  children: ?<span class="built_in">Array</span>&lt;VNode&gt;;</span><br><span class="line">  text: string | <span class="keyword">void</span>;</span><br><span class="line">  elm: Node | <span class="keyword">void</span>;</span><br><span class="line">  ns: string | <span class="keyword">void</span>;</span><br><span class="line">  context: Component | <span class="keyword">void</span>; <span class="comment">// rendered in this component&#x27;s scope</span></span><br><span class="line">  key: string | number | <span class="keyword">void</span>;</span><br><span class="line">  componentOptions: VNodeComponentOptions | <span class="keyword">void</span>;</span><br><span class="line">  componentInstance: Component | <span class="keyword">void</span>; <span class="comment">// component instance</span></span><br><span class="line">  parent: VNode | <span class="keyword">void</span>; <span class="comment">// component placeholder node</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// strictly internal</span></span><br><span class="line">  raw: boolean; <span class="comment">// contains raw HTML? (server only)</span></span><br><span class="line">  isStatic: boolean; <span class="comment">// hoisted static node</span></span><br><span class="line">  isRootInsert: boolean; <span class="comment">// necessary for enter transition check</span></span><br><span class="line">  isComment: boolean; <span class="comment">// empty comment placeholder?</span></span><br><span class="line">  isCloned: boolean; <span class="comment">// is a cloned node?</span></span><br><span class="line">  isOnce: boolean; <span class="comment">// is a v-once node?</span></span><br><span class="line">  asyncFactory: <span class="built_in">Function</span> | <span class="keyword">void</span>; <span class="comment">// async component factory function</span></span><br><span class="line">  asyncMeta: <span class="built_in">Object</span> | <span class="keyword">void</span>;</span><br><span class="line">  isAsyncPlaceholder: boolean;</span><br><span class="line">  ssrContext: <span class="built_in">Object</span> | <span class="keyword">void</span>;</span><br><span class="line">  fnContext: Component | <span class="keyword">void</span>; <span class="comment">// real context vm for functional nodes</span></span><br><span class="line">  fnOptions: ?ComponentOptions; <span class="comment">// for SSR caching</span></span><br><span class="line">  devtoolsMeta: ?<span class="built_in">Object</span>; <span class="comment">// used to store functional render context for devtools</span></span><br><span class="line">  fnScopeId: ?string; <span class="comment">// functional scope id support</span></span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    tag?: string,</span></span><br><span class="line"><span class="params">    data?: VNodeData,</span></span><br><span class="line"><span class="params">    children?: ?<span class="built_in">Array</span>&lt;VNode&gt;,</span></span><br><span class="line"><span class="params">    text?: string,</span></span><br><span class="line"><span class="params">    elm?: Node,</span></span><br><span class="line"><span class="params">    context?: Component,</span></span><br><span class="line"><span class="params">    componentOptions?: VNodeComponentOptions,</span></span><br><span class="line"><span class="params">    asyncFactory?: <span class="built_in">Function</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.tag = tag</span><br><span class="line">    <span class="built_in">this</span>.data = data</span><br><span class="line">    <span class="built_in">this</span>.children = children</span><br><span class="line">    <span class="built_in">this</span>.text = text</span><br><span class="line">    <span class="built_in">this</span>.elm = elm</span><br><span class="line">    <span class="built_in">this</span>.ns = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.context = context</span><br><span class="line">    <span class="built_in">this</span>.fnContext = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.fnOptions = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.fnScopeId = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.key = data &amp;&amp; data.key</span><br><span class="line">    <span class="built_in">this</span>.componentOptions = componentOptions</span><br><span class="line">    <span class="built_in">this</span>.componentInstance = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.parent = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.raw = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.isStatic = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.isRootInsert = <span class="literal">true</span></span><br><span class="line">    <span class="built_in">this</span>.isComment = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.isCloned = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.isOnce = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.asyncFactory = asyncFactory</span><br><span class="line">    <span class="built_in">this</span>.asyncMeta = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.isAsyncPlaceholder = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DEPRECATED: alias for componentInstance for backwards compat.</span></span><br><span class="line">  <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">  get child (): Component | <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.componentInstance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Vue2中的Vnode借鉴了<a href="https://github.com/snabbdom/snabbdom">snabbdom</a> 同样也可以参考我的另一篇文章<a href="http://www.tianhw.tk/2021/02/02/Vue%E6%A0%B8%E5%BF%83%E4%B9%8B%E8%99%9A%E6%8B%9FDOM%E4%B8%8EDiff%E7%AE%97%E6%B3%95/">Vue核心之虚拟DOM与Diff算法</a>,这里我也不再赘述。只不过Vue中的Vnode定义的较为复杂。</p>
<p>在这里稍微的总结一下：</p>
<p><code>render</code>将<code>AST</code>生成的<code>code</code>变为<code>Vnode</code>,<code>_update</code>将<code>Vnode</code>变为真实的DOM。</p>
<h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h3><p>Vuejs利用createElement函数来创建虚拟DOM，该函数定义在<code>src/core/vdom/create-element.js</code>中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  context: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  data: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  children: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  normalizationType: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  alwaysNormalize: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(data) || isPrimitive(data)) &#123;</span><br><span class="line">    normalizationType = children</span><br><span class="line">    children = data</span><br><span class="line">    data = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isTrue(alwaysNormalize)) &#123;</span><br><span class="line">    normalizationType = ALWAYS_NORMALIZE</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _createElement(context, tag, data, children, normalizationType)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>createElement</code>函数对传入的参数处理后传入<code>_createElement</code>中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">_createElement</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  context: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag?: string | Class&lt;Component&gt; | <span class="built_in">Function</span> | <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  data?: VNodeData,</span></span></span><br><span class="line"><span class="function"><span class="params">  children?: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  normalizationType?: number</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef((data: any).__ob__)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`Avoid using observed data object as vnode data: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>\n`</span> +</span><br><span class="line">      <span class="string">&#x27;Always create fresh vnode data objects in each render!&#x27;</span>,</span><br><span class="line">      context</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// object syntax in v-bind</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef(data.is)) &#123;</span><br><span class="line">    tag = data.is</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!tag) &#123;</span><br><span class="line">    <span class="comment">// in case of component :is set to falsy value</span></span><br><span class="line">    <span class="keyword">return</span> createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// warn against non-primitive key</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">    isDef(data) &amp;&amp; isDef(data.key) &amp;&amp; !isPrimitive(data.key)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!__WEEX__ || !(<span class="string">&#x27;@binding&#x27;</span> <span class="keyword">in</span> data.key)) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">&#x27;Avoid using non-primitive value as key, &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;use string/number value instead.&#x27;</span>,</span><br><span class="line">        context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// support single function children as default scoped slot</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children) &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> children[<span class="number">0</span>] === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    data = data || &#123;&#125;</span><br><span class="line">    data.scopedSlots = &#123; <span class="attr">default</span>: children[<span class="number">0</span>] &#125;</span><br><span class="line">    children.length = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (normalizationType === ALWAYS_NORMALIZE) &#123;</span><br><span class="line">    children = normalizeChildren(children)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalizationType === SIMPLE_NORMALIZE) &#123;</span><br><span class="line">    children = simpleNormalizeChildren(children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> vnode, ns</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> Ctor</span><br><span class="line">    ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)</span><br><span class="line">    <span class="keyword">if</span> (config.isReservedTag(tag)) &#123;</span><br><span class="line">      <span class="comment">// platform built-in elements</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; isDef(data) &amp;&amp; isDef(data.nativeOn)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`The .native modifier for v-on is only valid on components but it was used on &lt;<span class="subst">$&#123;tag&#125;</span>&gt;.`</span>,</span><br><span class="line">          context</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        config.parsePlatformTagName(tag), data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, <span class="string">&#x27;components&#x27;</span>, tag))) &#123;</span><br><span class="line">      <span class="comment">// component</span></span><br><span class="line">      vnode = createComponent(Ctor, data, context, children, tag)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// unknown or unlisted namespaced elements</span></span><br><span class="line">      <span class="comment">// check at runtime because it may get assigned a namespace when its</span></span><br><span class="line">      <span class="comment">// parent normalizes children</span></span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        tag, data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// direct component options / constructor</span></span><br><span class="line">    vnode = createComponent(tag, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(vnode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(vnode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(ns)) applyNS(vnode, ns)</span><br><span class="line">    <span class="keyword">if</span> (isDef(data)) registerDeepBindings(data)</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>_createElement</code>中传入了<code>normalizationType</code>参数，这个参数表示子节点规范的类型，类型不同规范的方法也就不一样。</p>
<p><code>createElement</code>函数中重点分析2个重点流程</p>
<ul>
<li>children的规范化</li>
<li>Vnode的创建</li>
</ul>
<h3 id="children-的规范化"><a href="#children-的规范化" class="headerlink" title="children 的规范化"></a>children 的规范化</h3><p><code>_createElement</code>接收的<code>children</code>可以是任意的类型，因此需要把他规范成<code>Vnode</code>类型，根据上面传入<code>normalizationType</code>的不同，调用不同的方法。主要的参考是<code>render</code>是编译生成还是用户手写的。</p>
<p>这些方法定义在<code>src/core/vdom/helpers/normalzie-children.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">simpleNormalizeChildren</span> (<span class="params">children: any</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.concat.apply([], children)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> children</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. When the children contains constructs that always generated nested Arrays,</span></span><br><span class="line"><span class="comment">// e.g. &lt;template&gt;, &lt;slot&gt;, v-for, or when the children is provided by user</span></span><br><span class="line"><span class="comment">// with hand-written render functions / JSX. In such cases a full normalization</span></span><br><span class="line"><span class="comment">// is needed to cater to all possible types of children values.</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">normalizeChildren</span> (<span class="params">children: any</span>): ?<span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isPrimitive(children)</span><br><span class="line">    ? [createTextVNode(children)]</span><br><span class="line">    : <span class="built_in">Array</span>.isArray(children)</span><br><span class="line">      ? normalizeArrayChildren(children)</span><br><span class="line">      : <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>simpleNormalizeChildren</code>:当<code>render</code>是编译生成的,children都是Vnode类型，但是 <code>functional component</code>函数式组件返回的是一个数组，所以会通过<code>*Array*.prototype.concat</code>将他的深度变成一层。</p>
<p><code>normalizeChildren</code>:这个方法的应用场景有2种，</p>
<ul>
<li>用户手写的render，当children只有一个节点会调用<code>createTextVNode</code>来创建这个简单的文本节点。</li>
<li>编译<code>solt</code>，<code>v-for</code> 产生嵌套数组会调用<code>normalizeArrayChildren</code>方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeArrayChildren</span> (<span class="params">children: any, nestedIndex?: string</span>): <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  <span class="keyword">let</span> i, c, lastIndex, last</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">    c = children[i]</span><br><span class="line">    <span class="keyword">if</span> (isUndef(c) || <span class="keyword">typeof</span> c === <span class="string">&#x27;boolean&#x27;</span>) <span class="keyword">continue</span></span><br><span class="line">    lastIndex = res.length - <span class="number">1</span></span><br><span class="line">    last = res[lastIndex]</span><br><span class="line">    <span class="comment">//  nested</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(c)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c = normalizeArrayChildren(c, <span class="string">`<span class="subst">$&#123;nestedIndex || <span class="string">&#x27;&#x27;</span>&#125;</span>_<span class="subst">$&#123;i&#125;</span>`</span>)</span><br><span class="line">        <span class="comment">// merge adjacent text nodes</span></span><br><span class="line">        <span class="keyword">if</span> (isTextNode(c[<span class="number">0</span>]) &amp;&amp; isTextNode(last)) &#123;</span><br><span class="line">          res[lastIndex] = createTextVNode(last.text + (c[<span class="number">0</span>]: any).text)</span><br><span class="line">          c.shift()</span><br><span class="line">        &#125;</span><br><span class="line">        res.push.apply(res, c)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPrimitive(c)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isTextNode(last)) &#123;</span><br><span class="line">        <span class="comment">// merge adjacent text nodes</span></span><br><span class="line">        <span class="comment">// this is necessary for SSR hydration because text nodes are</span></span><br><span class="line">        <span class="comment">// essentially merged when rendered to HTML strings</span></span><br><span class="line">        res[lastIndex] = createTextVNode(last.text + c)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c !== <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// convert primitive to vnode</span></span><br><span class="line">        res.push(createTextVNode(c))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isTextNode(c) &amp;&amp; isTextNode(last)) &#123;</span><br><span class="line">        <span class="comment">// merge adjacent text nodes</span></span><br><span class="line">        res[lastIndex] = createTextVNode(last.text + c.text)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// default key for nested array children (likely generated by v-for)</span></span><br><span class="line">        <span class="keyword">if</span> (isTrue(children._isVList) &amp;&amp;</span><br><span class="line">          isDef(c.tag) &amp;&amp;</span><br><span class="line">          isUndef(c.key) &amp;&amp;</span><br><span class="line">          isDef(nestedIndex)) &#123;</span><br><span class="line">          c.key = <span class="string">`__vlist<span class="subst">$&#123;nestedIndex&#125;</span>_<span class="subst">$&#123;i&#125;</span>__`</span></span><br><span class="line">        &#125;</span><br><span class="line">        res.push(c)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>nestedIndex</code> 表示嵌套的索引</p>
<p>这个函数的核心逻辑就是遍历<code>children</code></p>
<ul>
<li>child如果是一个数组则递归调用<code>normalizeArrayChildren</code>,</li>
<li>如果是基础类型就调用<code>createTextVNode</code>转化成<code>Vnode</code>类型，</li>
<li>如果children是一个列表，并且列表存在嵌套情况，则根据 <code>nestedIndex</code> 去更新它的 key</li>
</ul>
<p>上面3种情况都处理了如果有2个连续的<code>text</code>节点，就把他们合为一个</p>
<p>对<code>childern</code>规范化后，<code>childern</code>变为了<code>Vnode</code>类型</p>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>update的核心就是patch 可以参考我的另一篇文章<a href="http://www.tianhw.tk/2021/02/02/Vue%E6%A0%B8%E5%BF%83%E4%B9%8B%E8%99%9A%E6%8B%9FDOM%E4%B8%8EDiff%E7%AE%97%E6%B3%95/">Vue核心之虚拟DOM与Diff算法</a>,这里我也不再赘述。</p>
<p>update中的patch目前我也不是很清楚，以后再详细的分析一下吧。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue核心</tag>
      </tags>
  </entry>
  <entry>
    <title>原生nodejs封装express路由</title>
    <url>/2021/03/20/%E5%8E%9F%E7%94%9Fnodejs%E5%B0%81%E8%A3%85express%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<p><strong>Nodejs学习笔记</strong></p>
<p>Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</p>
<p>Nodejs异步变成的直接体现就是回调。</p>
<p>Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。</p>
<p>Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.</p>
<p>   所以nodejs是一个<strong>单线程</strong>，<strong>非阻塞式I/O</strong>，<strong>事件驱动</strong>怎么理解，本篇文章不做讲述</p>
<p><strong><em>封装一个类似与express的路由</em></strong></p>
<p>在这之前你需要了解以下内容：</p>
<ol>
<li>如何启动一个服务</li>
<li><code>path</code>,<code>url</code>,<code>fs</code>,<code>http</code>模块</li>
</ol>
<p>在启动服务后会执行<code>createServer</code>中传入的回调函数。基于这个我来尝试着封装下<strong>静态资源</strong>、<strong>路由</strong></p>
<p>多嘴一下什么是静态资源，什么是路由：静态资源指从服务器直接拿过来的数据，如<code>html</code>，<code>css</code>，<code>js</code>,<code>json</code>等等文件；路由如在url中<code>xxx.com/login</code>这里出现的<code>login</code>就是个路由,当访问<code>login</code>时，执行对应的逻辑。</p>
<h2 id="封装静态资源"><a href="#封装静态资源" class="headerlink" title="封装静态资源"></a>封装静态资源</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initStatic</span>(<span class="params">req, res, staticPath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> pathname = url.parse(req.url).pathname;</span><br><span class="line">  <span class="comment">// pathname = pathname === &quot;/&quot; ? &quot;/index.html&quot; : pathname;</span></span><br><span class="line">  <span class="keyword">let</span> extname = path.extname(pathname);</span><br><span class="line">  <span class="keyword">if</span> (extname) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> data = fs.readFileSync(<span class="string">&quot;./&quot;</span> + staticPath + pathname);</span><br><span class="line">      <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="keyword">let</span> mime = getFileMime(extname);</span><br><span class="line">        res.writeHead(<span class="number">200</span>, &#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;&quot;</span> + mime + <span class="string">&#x27;;charset=&quot;utf-8&quot;&#x27;</span>&#125;);</span><br><span class="line">        res.end(data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我是这里是如何区分是路由还是静态资源文件呢？ 我用后缀来判断，如果后缀存在，我才去加载对应的静态资源。</p>
<p>如果我读取文件不用<code>readFileSync</code>读取的话，就会出现文件加载不出来的情况,因为<code>readFile</code>方法是异步的。</p>
<p>上面代码使用了<code>getFileMime</code>工具函数，该函数的功能，就是根据不同的资源类型，来自动设置正确的<code>Content-Type</code>头</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileMime</span>(<span class="params">extname</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = fs.readFileSync(<span class="string">&quot;./data/mime.json&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> mimeObj = <span class="built_in">JSON</span>.parse(data.toString());</span><br><span class="line">  <span class="keyword">return</span> mimeObj[extname];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="封装路由"><a href="#封装路由" class="headerlink" title="封装路由"></a>封装路由</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initRoute</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> method = req.method.toLowerCase();</span><br><span class="line">  <span class="keyword">let</span> pathname = url.parse(req.url).pathname;</span><br><span class="line">  <span class="keyword">let</span> extname = path.extname(pathname);</span><br><span class="line">  <span class="keyword">if</span> (!extname) &#123;</span><br><span class="line">    <span class="keyword">if</span> (G[<span class="string">&quot;_&quot;</span> + method][pathname]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (method === <span class="string">&quot;get&quot;</span>) &#123;</span><br><span class="line">        G[<span class="string">&quot;_&quot;</span> + method][pathname](req, res);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method === <span class="string">&quot;post&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> postData = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        req.on(<span class="string">&quot;data&quot;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">          postData += chunk;</span><br><span class="line">        &#125;);</span><br><span class="line">        req.on(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          req.body = postData;</span><br><span class="line">          G[<span class="string">&quot;_&quot;</span> + method][pathname](req, res);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.writeHead(<span class="number">404</span>, &#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&#x27;text/html;charset=&quot;utf-8&quot;&#x27;</span>&#125;);</span><br><span class="line">      res.send(<span class="string">&quot;页面不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我只简单的封装了<code>get</code>，<code>post</code>请求</p>
<p>同样的我根据后缀名是否存在来判断是路由还是静态资源，我将<code>get</code>请求和<code>post</code>请求分别放在了不同的对象里，这样在请求方式不同的前提下，就算路由相同也会处理不同的逻辑。</p>
<p>如果是post请求，我把请求的数据给到<code>req.body</code>上,这样在<code>post</code>请求的回调中就可以拿到数据。</p>
<h2 id="总体"><a href="#总体" class="headerlink" title="总体"></a>总体</h2><p>我想让app函数中依托的数据不是那么的暴露在<code>route.js</code>作用域中，我索性将他封装到函数的作用域中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">server</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> G = &#123;</span><br><span class="line">    _get: &#123;&#125;,</span><br><span class="line">    _post: &#123;&#125;,</span><br><span class="line">    staticPath: <span class="string">&quot;static&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">app</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    changeRes(res);</span><br><span class="line">    initStatic(req, res, G.staticPath);</span><br><span class="line">    initRoute(req, res);</span><br><span class="line">  &#125;</span><br><span class="line">  app.get = <span class="function"><span class="keyword">function</span> (<span class="params">route, cb</span>) </span>&#123;</span><br><span class="line">    G._get[route] = cb;</span><br><span class="line">  &#125;;</span><br><span class="line">  app.post = <span class="function"><span class="keyword">function</span> (<span class="params">route, cb</span>) </span>&#123;</span><br><span class="line">    G._post[route] = cb;</span><br><span class="line">  &#125;;</span><br><span class="line">  app.static = <span class="function"><span class="keyword">function</span> (<span class="params">staticPath</span>) </span>&#123;</span><br><span class="line">    G.staticPath = staticPath;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我让他静态资源的默认路径是<code>static</code>,在后面你也可以自己来指定。</p>
<p>在<code>get/post</code>请求中，我将他的路由当做键名，回调函数当作值存起来，当触发路由时，我就根据键名直接执行我存起来的回调函数。</p>
<p>changeRes函数是给res上拓展方法的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeRes</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">  res.send = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&#x27;text/html;charset=&quot;utf-8&quot;&#x27;</span>&#125;);</span><br><span class="line">    res.end(data);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是html页面，我就可以直接使用<code>res.send</code></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>10种排序算法</title>
    <url>/2021/03/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>前言：今天写了一道排序的题，发现排序算法我都不知道如何使用，在不同的情况下该使用哪种排序算法，惭愧的是，我只会冒泡排序，所以本文章作为我重新学习排序算法的一个见证吧，本篇文章将从时间空间复杂度，算法的优化以及各种算法的使用场景来介绍各种算法。</p>
<p>本篇文章基于升序讲述！</p>
</blockquote>
<p>排序算法</p>
<p>这里有一个数据结构算法动画模拟网站，本篇文章图片资源来自<a href="http://senki.tgozzz.cn/"><strong>算法与数据结构可视化动态演练平台</strong></a></p>
<p>不过这个平台所能演示的算法并不是很多~</p>
<h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><ol>
<li>两两比较，将最大的置于最后面，然后排除最大的</li>
<li>将剩余的重复①操作</li>
</ol>
<p><code>arr = [[5,35,43,15,30,24]]</code></p>
<p><img src="https://i.loli.net/2021/03/13/8uVamItrhFkZwYR.png" alt="image-20210313170217246"></p>
<p>一次下来将43排到最后面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123; <span class="comment">//外层循环控制趟数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123; <span class="comment">//内层循环控制两两前后比较</span></span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化1"><a href="#优化1" class="headerlink" title="优化1"></a>优化1</h3><p>现在有这么一个情况，如果给的数组本来就是有序数组，那我们上面的算法依然会傻傻的执行这2层循环。</p>
<p>思考一下如果数组有序，那根本就走不进<code>if</code>语句,所以可以使用一个标识来表示数组是否有序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> sorted = <span class="literal">true</span>; <span class="comment">//有序标识</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">        sorted = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sorted) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意看，这里的<code>sorted</code>标识我是写到了第一层循环里面第二层循环外面，为什么这样做呢？因为你跑了几趟之后突然发现数组有序了，所以这样的比较好！</p>
<p>但是一般这种情况很少，而普遍的情况是数组的最后一部分有序，这就是我下来要介绍的优化2</p>
<h3 id="优化2"><a href="#优化2" class="headerlink" title="优化2"></a>优化2</h3><p>当数组的最后一部分有序了，我还傻傻的让程序去两两比较已经有序的序列，为了让我的程序更加的聪明，我决定每次比较记录下最后一次交换的下标，我让趟数直接从我记录的下标结束，这样不就少了挺多趟了嘛？</p>
<p><img src="https://i.loli.net/2021/03/13/LwpTeKVFfzDMu9G.png" alt="image-20210313182601083"></p>
<p>最后一组交换17和51，我记录下17的下标4，将前面的当成子数组，我就只需要对子数组进行排序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> end = arr.length - <span class="number">1</span>; end &gt; <span class="number">0</span>; end--)&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> begin = <span class="number">1</span>; begin &lt;= end; begin++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[begin - <span class="number">1</span>] &gt; arr[begin]) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[begin - <span class="number">1</span>];</span><br><span class="line">        arr[begin - <span class="number">1</span>] = arr[begin];</span><br><span class="line">        arr[begin] = temp;</span><br><span class="line">        index = begin;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    end = index;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我这里给<code>index</code>赋值为0我如果不这样写的话，如果数组是有序的,就还要走内层循环。这里理论上<code>index</code>可以赋值为小于2的数！</p>
<p>冒泡排序是<strong>稳定</strong>的</p>
<h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><p>选择排序就是在数组选择出最大（小）的放到数组的最前（后）面，同样的放好一个最后一个就不用管了，所以代码和冒泡的很像</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> end = arr.length - <span class="number">1</span>; end &gt; <span class="number">0</span>; end--) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> begin = <span class="number">1</span>; begin &lt;= end; begin++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[maxIndex] &lt;= arr[begin]) &#123;</span><br><span class="line">        maxIndex = begin;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[end];</span><br><span class="line">    arr[end] = arr[maxIndex];</span><br><span class="line">    arr[maxIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相较于冒泡选择好在哪?</p>
<p>可以看到选择排序每一趟只交换一次，而冒泡两两比较只要符合条件就会交换！！！</p>
<p>选择排序是<strong>不稳定</strong>的，虽然if里写了&lt;= 但他依然是不稳定的，只是增加了一些稳定的情况而已！</p>
<p><strong>两个概念：</strong></p>
<p><em>原地算法</em>：不依赖额外的资源或只依赖少数的资源</p>
<p><em>稳定性</em>：相等元素的相对位置不变（3a, 4, 2, 3b, 5）=&gt;(2, 3a, 3b, 4, 5)</p>
<h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><blockquote>
<p>堆就是一种特殊的完全二叉树</p>
<p>大根堆：任意节点都比其孩子节点大</p>
<p>小根堆：任意节点都比其孩子节点小</p>
</blockquote>
<p>在介绍堆排序前，我先说几个概念：</p>
<p>父节点为i求子节点</p>
<p><em>左孩子</em>：<strong>2i+1</strong></p>
<p><em>右孩子</em>：<strong>2i+2</strong></p>
<p>子节点为i求父节点：</p>
<p><strong>Math.floor((i-1)/2)</strong></p>
<p>堆排序：</p>
<ol>
<li>建堆</li>
<li>去堆顶，向下调整</li>
<li>重复3，直到堆为空</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="comment">//创建堆</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> n = <span class="built_in">Math</span>.floor((len - <span class="number">2</span>) / <span class="number">2</span>); n &gt; -<span class="number">1</span>; n--) &#123;</span><br><span class="line">    <span class="comment">//从最后一个非叶子节点开始</span></span><br><span class="line">    sift(arr, n, len - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt; -<span class="number">1</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[<span class="number">0</span>];  </span><br><span class="line">    arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">    arr[i] = temp;</span><br><span class="line">     <span class="comment">//将选出的最大数，放在已经处理过的位置</span></span><br><span class="line">    sift(arr, <span class="number">0</span>, i - <span class="number">1</span>);   </span><br><span class="line">    <span class="comment">//传入i-1是因为第i位已经不用管了</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sift</span>(<span class="params">arr, low, high</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = low,</span><br><span class="line">    j = <span class="number">2</span> * i + <span class="number">1</span>,</span><br><span class="line">    temp = arr[low];</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j + <span class="number">1</span> &lt; high &amp;&amp; arr[j + <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">      j = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[j] &gt; temp) &#123;</span><br><span class="line">      arr[i] = arr[j];</span><br><span class="line">      i = j;</span><br><span class="line">      j = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//这里 i j 分别指向当前层和下一层，当满足条件后，将值赋值后，将 i j 下移 </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[i] = temp;  <span class="comment">//无论是跳出循环或者是arr[i]比temp小，都要执行这句代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面用文字来描述下创建堆和向下调整的过程</p>
<p><img src="https://i.loli.net/2021/03/22/ue2swRKQaXBokId.png" alt="image-20210322152712510"></p>
<p>找到3这个节点后向下调整，依次是 -&gt;9-&gt; 1-&gt; 8-&gt; 6,向下调整的<code>low</code>好找，就是当前的节点序号，那么<code>high</code>应该写多少呢？上面代码中我直接写了<code>len-1</code>,因为在<code>sift</code>函数中<code>hight</code>只有限制边界这一个作用。所以len-1直接是够用了。</p>
<p><strong>向下调整</strong></p>
<p><img src="https://i.loli.net/2021/03/22/MGz3VQjkfPuxUXC.png" alt="image-20210322153739336"></p>
<p>我把3放上去后，然后选出8，放到最上面，接着看 6 和5这一层选出6，接着选出4，最后3就只能呆在4这个位置。</p>
<h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><p>遍历数组，如果当前数组元素比前面元素小，就把前面元素往后移然后将当前元素插入进去。</p>
<p><img src="https://i.loli.net/2021/03/21/t27PRTIzCKNArl3.png" alt="image-20210321153546180"></p>
<p>如图我判断到了<strong>34</strong>这个数，前面的数字都比<strong>34</strong>大，所以我将他们全部后移，这时<code>J == 0</code> 循环退出 ，我将<strong>34</strong>赋值给<code>J+1</code>位置的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[i];</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123; <span class="comment">//j&lt;0说明已经走到</span></span><br><span class="line">      <span class="built_in">console</span>.log(temp, arr[j]);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">123</span>);</span><br><span class="line">      arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><p>快速排序的思想是选出一个元素，比这个元素大的放右边，比这个元素小的放左边，</p>
<p><strong>其实就是把基准元素归位的一个过程</strong>！</p>
<p>放好之后，两边还有元素 (<strong>子数组</strong>) 就递归调用，一般的选取左边的元素为基准元素。</p>
<p><img src="https://i.loli.net/2021/03/21/8CwTDiou4FEBnxR.png" alt="image-20210321164821359"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">let</span> mid = partition(arr, left, right);</span><br><span class="line">    quickSort(arr, left, mid - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = arr[left];</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt;= temp) &#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = arr[right];   <span class="comment">//就算没上面的循环没有进入，赋值也就相当于 arr[left] = arr[left]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= temp) &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[right] = arr[left];</span><br><span class="line">  &#125;</span><br><span class="line">  arr[left] = temp;</span><br><span class="line">  <span class="keyword">return</span> left;   <span class="comment">//返回第一个数被插入的位置，把该位置当作左右递归的边界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果left==right后就要结束循环，并且将最左边的值赋值给左右指针指向的位置（相当于把基准元素归位）</p>
<h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><p>思想：两个有序序列合并成一个有序序列，就和当初学习两有序链表合并成一个链表一样！<br>把数组不停的对半分下去，当只有一个时，我merge两个只有一项的数组肯定行！</p>
<p>所以归并排序说穿了就是先对半分，再依次合并的一个过程</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.itxxb.com%2Fresource%2F20171206%2F1%2F20171206183742078_1.jpg&refer=http%3A%2F%2Fwww.itxxb.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1618997115&t=bfe3651c6e0facf156436be129c8a199" alt="点击查看源网页"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr, low, high</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((low + high) / <span class="number">2</span>);</span><br><span class="line">    mergeSort(arr, low, mid);</span><br><span class="line">    mergeSort(arr, mid + <span class="number">1</span>, high);</span><br><span class="line">    merge(arr, low, mid, high);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">arr, low, mid, high</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = low,</span><br><span class="line">    j = mid + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> tempArr = [];</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">      tempArr.push(arr[i]);</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tempArr.push(arr[j]);</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">    tempArr.push(arr[i]);</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">    tempArr.push(arr[j]);</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = low, j = <span class="number">0</span>; i &lt;= high; i++, j++) &#123;</span><br><span class="line">    arr[i] = tempArr[j];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面的图，<code>mid</code>指的就是7这个位置</p>
<h2 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h2><p>希尔排序就是分组的插入排序？那怎么分组呢？第一组d1 = n/2 第二组 d2 = d1/2…. 直到d==1</p>
<p><img src="https://i.loli.net/2021/03/22/Aav4PrYOdRJS1VM.png" alt="image-20210322181322167"></p>
<p><img src="https://i.loli.net/2021/03/22/UNrMvKGPpWy7Jhc.png" alt="image-20210322181344171"></p>
<p><img src="https://i.loli.net/2021/03/22/YJl4uNVtjm1C5SZ.png" alt="image-20210322181359801"></p>
<p>希尔排序就是慢慢的将数组变有序的排序方式！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort_gap</span>(<span class="params">arr, gap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i - gap;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[i];</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">      arr[j + gap] = arr[j];</span><br><span class="line">      j -= gap;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j + gap] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> d = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">while</span> (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    insertSort_gap(arr, d);</span><br><span class="line">    d = <span class="built_in">Math</span>.floor(d / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计数排序（Count-Sort）"><a href="#计数排序（Count-Sort）" class="headerlink" title="计数排序（Count Sort）"></a>计数排序（Count Sort）</h2><p>前提：<strong>知道要被排序数的范围</strong></p>
<p>遍历数组，数字每出现一次就加1,接着根据次数输出对应的数就好！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSort</span>(<span class="params">arr, maxCount = <span class="number">10</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="keyword">new</span> <span class="built_in">Array</span>(maxCount).fill(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = arr[i]</span><br><span class="line">    count[index] =count[index]+<span class="number">1</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  arr = [];</span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (count[i]!==<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> j = count[i];</span><br><span class="line">      <span class="keyword">while</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        arr.push(i);</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h2><p>试想一下，如果只有10个数字需要排序，但这10个数字最大的是10000，采用计数排序的话，我就需要一个长度为10000的数组。</p>
<p>桶排序就是把这个超长的范围划分出几个小段，把对应的数放在对应的段里</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span>(<span class="params">arr, n = <span class="number">10</span>, maxNum = <span class="number">100</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> buckets = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> tArr = [];</span><br><span class="line">    buckets.push(tArr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="built_in">Math</span>.min(<span class="built_in">Math</span>.floor(arr[i] / <span class="built_in">Math</span>.floor(maxNum / n)), n - <span class="number">1</span>);</span><br><span class="line">    buckets[index].push(arr[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = buckets[index].length - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (buckets[index][j] &lt; buckets[index][j - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = buckets[index][j];</span><br><span class="line">        buckets[index][j] = buckets[index][j - <span class="number">1</span>];</span><br><span class="line">        buckets[index][j - <span class="number">1</span>] = temp;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">    arr = arr.concat(...buckets[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在给桶里添加数据的时候，像冒泡排序一样，把新的数插在合适的位置。这样排序后的数组就只需要顺序输出就好了</p>
<p><img src="https://i.loli.net/2021/03/22/fRAqewn1YrF38j2.png" alt="image-20210322204029891"></p>
<h2 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h2><p>思想：从每个数的个位开始，根据个位的数字，放到对应的桶里（个位是1就放到1号桶里），然后从桶中一次把数字取出赋给原数组。</p>
<p>接下来10位、百位…</p>
<p><strong>该方法循环最大数字的位数！</strong></p>
<p>这里拿出一个数组：[12，22，43，32，26，45]</p>
<p>由于我给出的数字在1- 6之间，为了画图方便，我给出6个桶，执行次数及结果如下图所示：</p>
<p><img src="https://i.loli.net/2021/03/31/5hwE27oDeqCpdic.png" alt="image-20210331213729527"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span>(<span class="params">li</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> max_num = <span class="built_in">Math</span>.max(...li);</span><br><span class="line">  <span class="keyword">let</span> it = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">10</span> ** it &lt;= max_num) &#123;</span><br><span class="line">    <span class="keyword">let</span> buckets = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);  <span class="comment">//只有10个数字所以创建10个桶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> arr = [];</span><br><span class="line">      buckets[i] = arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; li.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> digit = <span class="built_in">Math</span>.floor(li[i] / <span class="number">10</span> ** it) % <span class="number">10</span>;  <span class="comment">//第一次循环取个位，第二次取10位...</span></span><br><span class="line">      buckets[digit].push(li[i]);  <span class="comment">//将对应的数字放到对应的桶里</span></span><br><span class="line">    &#125;</span><br><span class="line">    li = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (buckets[i].length !== <span class="number">0</span>) &#123;</span><br><span class="line">        li = li.concat(buckets[i]);   <span class="comment">//顺序取出桶中的数字并赋值给原数组</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    it++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> li</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：</p>
<ol>
<li>为什么这样的操作后数组就变得有序呢？因为桶是有序的</li>
<li>如果给出的数字位数不一样会有影响吗?  没有影响当it值大于的话，那些小的数字就会被排到0号桶里完全是没有影响的</li>
</ol>
<h2 id="时间空间复杂度："><a href="#时间空间复杂度：" class="headerlink" title="时间空间复杂度："></a>时间空间复杂度：</h2><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">时间复杂度</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡</td>
<td align="center">n<sup>2</sup></td>
<td align="center">1</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">选择</td>
<td align="center">n<sup>2</sup></td>
<td align="center">1</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">插入</td>
<td align="center">n<sup>2</sup></td>
<td align="center">1</td>
<td align="center">稳</td>
</tr>
<tr>
<td align="center">堆</td>
<td align="center">nlog<sub>2</sub>n</td>
<td align="center">1</td>
<td align="center">不稳</td>
</tr>
<tr>
<td align="center">快速</td>
<td align="center">nlog<sub>2</sub>n</td>
<td align="center">log<sub>2</sub>n</td>
<td align="center">不稳</td>
</tr>
<tr>
<td align="center">归并</td>
<td align="center">nlog<sub>2</sub>n</td>
<td align="center">n</td>
<td align="center">稳</td>
</tr>
<tr>
<td align="center">希尔</td>
<td align="center">n<sup>1.3</sup></td>
<td align="center">1</td>
<td align="center">不稳</td>
</tr>
<tr>
<td align="center">计数</td>
<td align="center">n+k</td>
<td align="center">n+k</td>
<td align="center">稳</td>
</tr>
<tr>
<td align="center">桶</td>
<td align="center">n+k</td>
<td align="center">n+k</td>
<td align="center">稳</td>
</tr>
<tr>
<td align="center">基数</td>
<td align="center">n*k</td>
<td align="center">n+k</td>
<td align="center">稳</td>
</tr>
</tbody></table>
<p>关于稳定性的判断：凡是跳着交换的都是不稳定的，挨着交换的就是稳定的</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>第8章-开发美团网首页-登录注册</title>
    <url>/2021/04/12/%E7%AC%AC8%E7%AB%A0-%E5%BC%80%E5%8F%91%E7%BE%8E%E5%9B%A2%E7%BD%91%E9%A6%96%E9%A1%B5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<p><strong><a href="http://www.tianhw.tk/2021/04/12/%E7%BE%8E%E5%9B%A2%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE%E5%AF%BC%E8%88%AA%E5%B8%96/">集合导航贴</a></strong></p>
<p><strong><a href="https://github.com/adminthw/meituan-app">项目地址</a></strong></p>
<h1 id="第8章-开发美团网首页-登录注册"><a href="#第8章-开发美团网首页-登录注册" class="headerlink" title="第8章-开发美团网首页-登录注册"></a>第8章-开发美团网首页-登录注册</h1><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>代码都比较好读懂，没有什么特别高深的东西哦~</p>
<p>如果非要说比较难看懂的代码的话，那就是包里自带的方法了，我名字都看不懂哈哈，外国人写包的时候能不能搞个<strong>中文拼音版</strong>的哈哈，</p>
<p>我画了一半的流程图，觉得没必要画完。完全没必要，就是一些条件判断罢了。我在这里简单的说一下</p>
<ol>
<li><p>查看验证码是否有效</p>
<ol>
<li>验证码不正确</li>
<li>验证码没有填写</li>
<li>验证码过期（结束）</li>
</ol>
</li>
<li><p>用户是否在数据库中存在</p>
<ol>
<li>存在（结束）</li>
<li>不存在<ol>
<li>写入数据库<ol>
<li>写入失败（结束）</li>
<li>写入成功并登录<ol>
<li>登录失败（结束）</li>
<li>登录成功</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.post(<span class="string">&quot;/singup&quot;</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; username, password, email, code &#125; = ctx.request.body;</span><br><span class="line">  <span class="keyword">if</span> (code) &#123;</span><br><span class="line">    <span class="keyword">const</span> saveCode = <span class="keyword">await</span> Store.hget(<span class="string">`nodemail:<span class="subst">$&#123;username&#125;</span>`</span>, <span class="string">&quot;code&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> saveExpire = <span class="keyword">await</span> Store.hget(<span class="string">`nodemail:<span class="subst">$&#123;username&#125;</span>`</span>, <span class="string">&quot;expire&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (code === saveCode) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - saveExpire &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ctx.body = &#123;</span><br><span class="line">          code: -<span class="number">1</span>,</span><br><span class="line">          msg: <span class="string">&quot;验证码过期&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ctx.body = &#123;</span><br><span class="line">        code: -<span class="number">1</span>,</span><br><span class="line">        msg: <span class="string">&quot;请输入正确的验证码&quot;</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      code: -<span class="number">1</span>,</span><br><span class="line">      msg: <span class="string">&quot;请输入验证码&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> user = <span class="keyword">await</span> User.find(&#123;</span><br><span class="line">    username</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (user.length) &#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      code: -<span class="number">1</span>,</span><br><span class="line">      msg: <span class="string">&quot;用户名已经被注册&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> nuser = <span class="keyword">await</span> User.create(&#123; username, password, email &#125;);</span><br><span class="line">  <span class="keyword">if</span> (nuser) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> axios.post(<span class="string">&quot;/users/singin&quot;</span>, &#123;</span><br><span class="line">      username,</span><br><span class="line">      password</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (res.data &amp;&amp; res.data === <span class="number">0</span>) &#123;</span><br><span class="line">      ctx.body = &#123;</span><br><span class="line">        code: <span class="number">0</span>,</span><br><span class="line">        msg: <span class="string">&quot;注册成功&quot;</span>,</span><br><span class="line">        user: res.data.user</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ctx.body = &#123;</span><br><span class="line">        code: -<span class="number">1</span>,</span><br><span class="line">        msg: <span class="string">&quot;error&quot;</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      code: -<span class="number">1</span>,</span><br><span class="line">      msg: <span class="string">&quot;注册失败&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>登录接口的回调函数返回了<code>Passport.authenticate()</code>方法的执行结果这里算是个固定的写法，我就不再赘述了，参考代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.post(<span class="string">&quot;/singin&quot;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> Passport.authenticate(<span class="string">&quot;local&quot;</span>, <span class="function">(<span class="params">err, user, inf, status</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      ctx.body = &#123;</span><br><span class="line">        code: -<span class="number">1</span>,</span><br><span class="line">        msg: err</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (user) &#123;</span><br><span class="line">        ctx.body = &#123;</span><br><span class="line">          code: <span class="number">0</span>,</span><br><span class="line">          msg: <span class="string">&quot;登陆成功&quot;</span>,</span><br><span class="line">          user</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> ctx.login(user);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.body = &#123;</span><br><span class="line">          code: -<span class="number">1</span>,</span><br><span class="line">          msg: inf</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(ctx, next);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="发送验证码"><a href="#发送验证码" class="headerlink" title="发送验证码"></a>发送验证码</h2><p>大概流程</p>
<ol>
<li>检查数据库（redis）中是否存了该昵称下的到期时间<ol>
<li>存在并且现在的时间和注册的时间差小于1分钟（结束）</li>
</ol>
</li>
<li>调用<code>nodeMailer.createTransport()</code>方法传入smtp服务相关的信息</li>
<li>定义验证码，过期时间，邮箱，用户名</li>
<li>定义邮件内容格式</li>
<li>调用<code>transporter.sendMail()</code>传入邮件内容<ol>
<li>失败（结束）</li>
<li>成功（将数据写入Redis）</li>
</ol>
</li>
<li>响应成功报文</li>
</ol>
<h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><p><code>ctx.isAuthenticated()</code>这个是就有的方法</p>
<ol>
<li>等待<code>ctx.lagout()</code></li>
<li><em>ctx</em>.isAuthenticated()是否成功<ol>
<li>成功报文</li>
<li>失败报文</li>
</ol>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">&quot;/exit&quot;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> ctx.logout();</span><br><span class="line">  <span class="keyword">if</span> (!ctx.isAuthenticated()) &#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      code: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      code: -<span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="获取用户信息"><a href="#获取用户信息" class="headerlink" title="获取用户信息"></a>获取用户信息</h2><ol>
<li><code>ctx.isAuthenticated()</code>是否有<ol>
<li>没有，返回空邮箱和空用户名</li>
<li>有，返回邮箱和用户名’</li>
</ol>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">&quot;/getUser&quot;</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.isAuthenticated()) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; username, email &#125; = ctx.session.passport.user;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      user: username,</span><br><span class="line">      email</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      user: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      email: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当登录成功后，会将服务器的session存在客户端的cookie中，用户名字的显示使用了mounted钩子函数（当然也可以使用VueX），当页面加载完成时获取用户数据获取成功给user用户名赋值，就会显示用户名</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    status,</span><br><span class="line">    data: &#123; user &#125;,</span><br><span class="line">  &#125; = <span class="keyword">await</span> <span class="built_in">this</span>.$axios.get(<span class="string">&quot;/users/getUser&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.user = user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>


<p>当点击退出按钮时，会跳到/exit路由，这个路由中写了一个中间件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">middleware: <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; status, data &#125; = <span class="keyword">await</span> ctx.$axios.get(<span class="string">&quot;/users/exit&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (status === <span class="number">200</span> &amp;&amp; data &amp;&amp; data.code === <span class="number">0</span>) &#123;</span><br><span class="line">    location.href = <span class="string">&quot;/&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>中间件参考洋葱~</p>
<p><strong>本节补充</strong></p>
<p>登录注册时密码明文不太好，这里采用了md5加密</p>
<p>用户名用这个方法<code>encodeURIComponent</code>编码处理</p>
]]></content>
      <categories>
        <category>实战项目</category>
      </categories>
      <tags>
        <tag>美团全栈项目</tag>
      </tags>
  </entry>
  <entry>
    <title>美团全栈项目导航帖</title>
    <url>/2021/04/12/%E7%BE%8E%E5%9B%A2%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE%E5%AF%BC%E8%88%AA%E5%B8%96/</url>
    <content><![CDATA[<blockquote>
<p>本文为导航文章，该合集旨在记录我学这个项目时候需要记录的重点，我是边看教学视频<del>边写代码</del>边抄代码,所以写这些也可以达到二次记忆的目的</p>
</blockquote>
<p>由于前6章都是基本知识的铺垫，第七章为纯HTML布局，所以这个合集我从第八章开始</p>
<h2 id="第8章-开发美团网首页-登录注册"><a href="#第8章-开发美团网首页-登录注册" class="headerlink" title="第8章-开发美团网首页-登录注册"></a><strong><a href="http://www.tianhw.tk/2021/04/12/%E7%AC%AC8%E7%AB%A0-%E5%BC%80%E5%8F%91%E7%BE%8E%E5%9B%A2%E7%BD%91%E9%A6%96%E9%A1%B5-%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C/">第8章-开发美团网首页-登录注册</a></strong></h2><h2 id="第9章-开发美团网首页-Search搜索"><a href="#第9章-开发美团网首页-Search搜索" class="headerlink" title="第9章-开发美团网首页-Search搜索"></a><a href="http://www.tianhw.tk/2021/04/15/%E7%AC%AC9%E7%AB%A0-%E5%BC%80%E5%8F%91%E7%BE%8E%E5%9B%A2%E7%BD%91%E9%A6%96%E9%A1%B5-Search/">第9章-开发美团网首页-Search搜索</a></h2><h2 id="第10章-切换城市页"><a href="#第10章-切换城市页" class="headerlink" title="第10章-切换城市页"></a><a href="http://www.tianhw.tk/2021/04/15/%E7%AC%AC10%E7%AB%A0-%E5%88%87%E6%8D%A2%E5%9F%8E%E5%B8%82%E9%A1%B5/">第10章-切换城市页</a></h2><p>由于下面几章没有啥东西我将他们放在了一起~</p>
<h2 id="第11-12-13-14-章合集"><a href="#第11-12-13-14-章合集" class="headerlink" title="第11,12,13,14-章合集"></a><a href="http://www.tianhw.tk/2021/04/17/%E7%AC%AC11,12,13,14-%E7%AB%A0%E5%90%88%E9%9B%86">第11,12,13,14-章合集</a></h2><h2 id="第15章-总结-项目地址"><a href="#第15章-总结-项目地址" class="headerlink" title="第15章-总结+项目地址"></a><a href="https://github.com/adminthw/meituan-app">第15章-总结+项目地址</a></h2>]]></content>
      <categories>
        <category>实战项目</category>
      </categories>
      <tags>
        <tag>美团全栈项目</tag>
      </tags>
  </entry>
  <entry>
    <title>第9章-开发美团网首页-Search搜索</title>
    <url>/2021/04/15/%E7%AC%AC9%E7%AB%A0-%E5%BC%80%E5%8F%91%E7%BE%8E%E5%9B%A2%E7%BD%91%E9%A6%96%E9%A1%B5-Search/</url>
    <content><![CDATA[<p><strong><a href="http://www.tianhw.tk/2021/04/12/%E7%BE%8E%E5%9B%A2%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE%E5%AF%BC%E8%88%AA%E5%B8%96/">集合导航贴</a></strong></p>
<p><strong><a href="https://github.com/adminthw/meituan-app">项目地址</a></strong></p>
<h1 id="第9章-开发美团网首页-Search搜索"><a href="#第9章-开发美团网首页-Search搜索" class="headerlink" title="第9章-开发美团网首页-Search搜索"></a>第9章-开发美团网首页-Search搜索</h1><p>本章主要开发了搜索相关的功能。所有数据均来自我于数据库</p>
<h2 id="input搜索框"><a href="#input搜索框" class="headerlink" title="input搜索框"></a>input搜索框</h2><p><img src="https://i.loli.net/2021/04/15/V37ZM9gtbu12Klj.png" alt="image-20210415093447891"></p>
<ol>
<li><p>输入商品名称查找</p>
</li>
<li><p>input底部的内容</p>
</li>
<li><p>当输入框聚焦时未输入文字时的推荐</p>
</li>
<li><p>当输入框中聚焦且输入文字时的推荐</p>
</li>
</ol>
<p>上一章已经在VueX中有了<code>Position</code>数据,本章的所有请求都会携带<code>City</code>参数在数据库中查询！</p>
<p>在服务端要拿store中的数据要通过<code>ctx.store</code>来拿取</p>
<p>本节要注意的点是Input事件要添加防抖（debounce）,防抖函数传入的函数必须是<strong>普通函数</strong>，不然拿不到Vue实例</p>
<p>mongodb模糊查询：<code>name: new RegExp(ctx.query.input)</code>  <strong>ctx.query</strong>获取的是<em>get</em>传值，get传值必须写在<code>params</code>里</p>
<p>获取位置信息或热门推荐等初始的数据的代码都在<code>nuxtServerInit(&#123; commit &#125;, &#123; req, app &#125;)</code>钩子函数中。</p>
<h2 id="分类数据的获取"><a href="#分类数据的获取" class="headerlink" title="分类数据的获取"></a>分类数据的获取</h2><p><img src="https://i.loli.net/2021/04/15/oQlIj2T83AnM9yp.png" alt="image-20210415135407251"></p>
<p>分类数据也是算作是初始的信息，所以也在<code>store/index</code>中,在<code>nuxtServerInit</code>中发送请求要使用<code>app.axios</code></p>
<h2 id="有格调"><a href="#有格调" class="headerlink" title="有格调"></a>有格调</h2><p><img src="https://i.loli.net/2021/04/15/Tf89cqKxLN3jXwH.png" alt="image-20210415135821123"></p>
<p>默认是全部，在mounted钩子函数中执行一次请求，因为加载相对标签下面的数据是在<code>mouseover</code>的条件下的.图片数据是利用计算属性返回对相应<code>kind</code>下的数据,关于教程的代码他每次移动到正确位置上（dd）都会发送一次请求，上面的标签既然是写死的，到还不如一次性把数据获取全部赋值了.</p>
<p>教程中这块没有对应的数据内容，数据是我自己写的，所以数据都是一样的，而且这个接口并没有携带位置参数。我这边意思意思。</p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ol>
<li>Classic mode for store/ is deprecated and will be removed in Nuxt 3.</li>
</ol>
<p>打包时老是出现这句话，查了一下在Nuxt中，直接写name.js就行，不用整到model中去了，和路由相似</p>
<ol start="2">
<li>server/model</li>
</ol>
<p>model中的文件名要和Collection相对应。</p>
<ol start="3">
<li>给一堆元素添加事件的时候，利用事件委托，把事件写到父元素上</li>
</ol>
]]></content>
      <categories>
        <category>实战项目</category>
      </categories>
      <tags>
        <tag>美团全栈项目</tag>
      </tags>
  </entry>
  <entry>
    <title>第10章-切换城市页</title>
    <url>/2021/04/15/%E7%AC%AC10%E7%AB%A0-%E5%88%87%E6%8D%A2%E5%9F%8E%E5%B8%82%E9%A1%B5/</url>
    <content><![CDATA[<p><strong><a href="http://www.tianhw.tk/2021/04/12/%E7%BE%8E%E5%9B%A2%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE%E5%AF%BC%E8%88%AA%E5%B8%96/">集合导航贴</a></strong></p>
<p><strong><a href="https://github.com/adminthw/meituan-app">项目地址</a></strong></p>
<h1 id="第10章-切换城市页"><a href="#第10章-切换城市页" class="headerlink" title="第10章-切换城市页"></a>第10章-切换城市页</h1><h2 id="第一框"><a href="#第一框" class="headerlink" title="第一框"></a>第一框</h2><p><img src="https://i.loli.net/2021/04/15/7HfXhGvyCdYcJsN.png" alt="image-20210415205008723"></p>
<p>第一个框框的选了之后第二个框才会解除禁用状态</p>
<p><strong>思路</strong>：检测（watch）第一个框的值，如果值改变我就给<code>city</code>数组赋值，<code>city</code>有值我再开启第二个框，<code>province</code>我直接在<code>mounted</code>中直接获取</p>
<h2 id="第二框"><a href="#第二框" class="headerlink" title="第二框"></a>第二框</h2><p><img src="https://i.loli.net/2021/04/15/mhLB3HS6fkaRr4G.png" alt="image-20210415205035005"></p>
<p>第二个框我采用了ElementUI的远程搜索框。</p>
<p><strong>注意</strong>：防抖</p>
<h2 id="第三框"><a href="#第三框" class="headerlink" title="第三框"></a>第三框</h2><p><img src="https://i.loli.net/2021/04/15/8HeQZALSvT7glFk.png" alt="image-20210415205054736"></p>
<p>第三个框，我只写了一点点的DOM结构</p>
<p>首字母我遍历的是一个字母数组<code>   list:&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;.split(&#39;&#39;),</code>。</p>
<p>下面的ABC是怎么排列好的呢？显然后台是不会排的，没有接口来调用，我就自己动手</p>
<ol>
<li><p>我使用<code>js-pinyin</code>这个库将获取到的城市名称的第一个字母</p>
</li>
<li><p>判断是否在<code>a-z</code>之间否则返回<code>[ ]</code></p>
</li>
<li><p>遍历返回的数据取出首字母和名称<code>[&#123;title:&#39;&#39;,city:[]&#125;]</code> </p>
</li>
<li><p>根据<code>title</code>通过sort函数排列出正确的顺序</p>
</li>
</ol>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>第三框：使用<code>charCodeAt</code>方法转换成对应的<code>ASCII</code>来比较大小</p>
<p>首字母对应的城市名并无跳转功能，可二次开发</p>
<p>重难代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      list:<span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>.split(<span class="string">&#x27;&#x27;</span>),</span><br><span class="line">      block:[]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,  </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self=<span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> blocks=[]</span><br><span class="line">    <span class="keyword">let</span> &#123;status,<span class="attr">data</span>:&#123;city&#125;&#125;=<span class="keyword">await</span> self.$axios.get(<span class="string">&#x27;/geo/city&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(status===<span class="number">200</span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> p</span><br><span class="line">      <span class="keyword">let</span> c</span><br><span class="line">      <span class="keyword">let</span> d=&#123;&#125;</span><br><span class="line">      city.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        p=pyjs.getFullChars(item.name).toLocaleLowerCase().slice(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        c=p.charCodeAt(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(c&gt;<span class="number">96</span>&amp;&amp;c&lt;<span class="number">123</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(!d[p])&#123;</span><br><span class="line">            d[p]=[]</span><br><span class="line">          &#125;</span><br><span class="line">          d[p].push(item.name)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> [k,v] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(d))&#123;</span><br><span class="line">        blocks.push(&#123;</span><br><span class="line">          title:k.toUpperCase(),</span><br><span class="line">          city:v</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      blocks.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a.title.charCodeAt(<span class="number">0</span>)-b.title.charCodeAt(<span class="number">0</span>))</span><br><span class="line">      self.block=blocks</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>第二框：通过过滤函数筛选出带有输入文字的城市，但未对拼音处理。</p>
]]></content>
      <categories>
        <category>实战项目</category>
      </categories>
      <tags>
        <tag>美团全栈项目</tag>
      </tags>
  </entry>
  <entry>
    <title>第11,12,13,14章合集</title>
    <url>/2021/04/17/%E7%AC%AC11,12,13,14%E7%AB%A0-%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<p><strong><a href="http://www.tianhw.tk/2021/04/12/%E7%BE%8E%E5%9B%A2%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE%E5%AF%BC%E8%88%AA%E5%B8%96/">集合导航贴</a></strong></p>
<p><strong><a href="https://github.com/adminthw/meituan-app">项目地址</a></strong></p>
<blockquote>
<p>本章难度不是很大，通过本章可以学习到怎么给一个网页划分组件（组件化开发），优化DOM结构，组件之间的传值（Components by value），以及如何使用高德地图开发者平台</p>
</blockquote>
<h1 id="第11章-美团网产品列表页"><a href="#第11章-美团网产品列表页" class="headerlink" title="第11章-美团网产品列表页"></a>第11章-美团网产品列表页</h1><p>由于数据库数据过少，我索性将keyword参数固定成酒店，本章可进行二次开发的地方较多。</p>
<h2 id="页面布局的细分"><a href="#页面布局的细分" class="headerlink" title="页面布局的细分"></a>页面布局的细分</h2><p>由下图可以看到主体采用左右布局，右边是个地图，左边是3行。</p>
<p>左边最上面是面包屑中间是一个分类列表下边是一个<code>ul</code></p>
<p>学习布局就是学习组件化。由上面2行文字可以将该页面抽离成地图、面包屑、分类列表、分类的展开、ul、ul下面的产品。这样不但结构清晰，而且书写的DOM结构也很少。</p>
<p><img src="https://i.loli.net/2021/04/17/cvayJRTsnOHb27p.png" alt="image-20210417184029739"></p>
<h2 id="相关接口的开发"><a href="#相关接口的开发" class="headerlink" title="相关接口的开发"></a>相关接口的开发</h2><p>本章开发了<code>category.js</code>下面接口。ul下面的列表是请求上一章的<code>/search/resultsByKeywords</code>接口，解析url中的<code>keyword</code>参数并将参数传入<code>/search/resultsByKeywords</code>中，获取相关的数据。分类列表的参数由于数据太少，我直接写成死的。</p>
<h2 id="高德地图开发者"><a href="#高德地图开发者" class="headerlink" title="高德地图开发者"></a>高德地图开发者</h2><p>高德地图开发平台-&gt;注册-&gt;创建应用-&gt;获取key-&gt;按照文档书写JavaScript代码</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>本节注意：<code>mongo</code>在创建集合名时会默认在后面加上s，如果你的集合不是以s结尾，在<code>mongoose</code>中，是获取不到数据的，<strong>解决办法</strong>：<code>mongoose.model(&quot;name&quot;,Schema,collectionName)</code></p>
<ul>
<li><input disabled="" type="checkbox"> 本节点击按钮排序</li>
<li><input disabled="" type="checkbox"> 鼠标滑动到不同位置，地图改变</li>
<li><input disabled="" type="checkbox"> 翻页或者懒加载</li>
</ul>
<p>父组件给子组件传值未传值，如果是引用值，子组件的<code>default</code>应当返回应用值如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">default</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>


<h1 id="第12章-美团网产品详情页开发"><a href="#第12章-美团网产品详情页开发" class="headerlink" title="第12章 美团网产品详情页开发"></a>第12章 美团网产品详情页开发</h1><p>本章主要做了以下3个方面的事情</p>
<h2 id="面包屑组件"><a href="#面包屑组件" class="headerlink" title="面包屑组件"></a>面包屑组件</h2><p>直接套用<code>ElementUI</code>的面包屑组件通过<code>VueX</code>中的<code>position</code>和父组件中传入<code>Type</code>达到显示不同类型和地区的效果。</p>
<h2 id="店铺详情卡片"><a href="#店铺详情卡片" class="headerlink" title="店铺详情卡片"></a>店铺详情卡片</h2><p>直接请求接口渲染，没什么需要注意的点。</p>
<h2 id="商家团购优惠卡片"><a href="#商家团购优惠卡片" class="headerlink" title="商家团购优惠卡片"></a>商家团购优惠卡片</h2><p>这里主要的特点就是做了一层拦截，如果为未登录状态，则不能查看优惠信息，当然这里的信息和上面好像关联不是很大，因为我的数据有限~</p>
<p>这一章没啥说的，放张图吧~~</p>
<p><img src="https://i.loli.net/2021/04/18/odZ5rTJxAUV7Xks.png" alt="image-20210418185859978"></p>
<p>再放一张登录的</p>
<p><img src="https://i.loli.net/2021/04/18/CHX7e4o59LViZjv.png" alt="image-20210418190101634"></p>
<h1 id="第13章-购物车开发"><a href="#第13章-购物车开发" class="headerlink" title="第13章 购物车开发"></a>第13章 购物车开发</h1><p>购物车倒还挺麻烦，我在这里说下，每次点一个商品后都会生成一个购物车，所以不像淘宝那样只有一个购物车~</p>
<p>购物车这里用了<code>el-table</code>因为数量这里有一个计数器，所以哈，不能用<code>prop</code>来控制了~,采用模板的方式，给他绑定上<code>count</code>变量。总价那里也是会随着数量变化的，故我也使用了一个模板！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;el-table-column label=<span class="string">&quot;数量&quot;</span> width=<span class="string">&quot;212&quot;</span>&gt;</span><br><span class="line">      &lt;template slot-scope=<span class="string">&quot;scope&quot;</span>&gt;</span><br><span class="line">        &lt;el-input-number v-model=<span class="string">&quot;scope.row.count&quot;</span> :min=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/el-table-column&gt;</span><br><span class="line">    &lt;el-table-column label=<span class="string">&quot;总价&quot;</span>&gt;</span><br><span class="line">      &lt;template slot-scope=<span class="string">&quot;scope&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">          &#123;&#123; scope.row.price * scope.row.count &#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/el-table-column&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意的一小点是：子组件中绑定数据的是驼峰命名，我在给父组件传值的时候使用了<code>:*cart-data*=&quot;cart&quot;</code>,</p>
<p>为啥，我将父组件的值传给子组件，子组件修改后会反应到父组件上呢？因为<code>cart</code>是个数组是引用值哈哈哈</p>
<p><img src="https://i.loli.net/2021/04/18/fhtMY1BWsaQFoUH.png" alt="image-20210418190134236"></p>
<p>上一个页面会将购物车的ID通过URL传过来，这边就通过ID查询购物车中的东西，当点击提交订单后就会跳转到第14章啦</p>
<h1 id="第14章-订单页开发"><a href="#第14章-订单页开发" class="headerlink" title="第14章 订单页开发"></a>第14章 订单页开发</h1><p>点击13章的按钮后，他会请求创建订单接口，到达order页面后请求获取订单接口。</p>
<p>由于无支付系统，就勉勉强强跟着教程做到了这个地方，所有的订单只能做到未付款这里。</p>
<p><code>el-tabs</code>这里就不讲了，聪明的小伙伴一下就看出来这是个两列布局~</p>
<p><img src="https://i.loli.net/2021/04/18/zSfk789UnXLaQ4s.png" alt="image-20210418191423095"></p>
<p><img src="https://i.loli.net/2021/04/18/zSfk789UnXLaQ4s.png"></p>
]]></content>
      <categories>
        <category>实战项目</category>
      </categories>
      <tags>
        <tag>美团全栈项目</tag>
      </tags>
  </entry>
  <entry>
    <title>手机维修记</title>
    <url>/2021/05/15/%E6%89%8B%E6%9C%BA%E7%BB%B4%E4%BF%AE%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>修手机没有那么麻烦，手机不就是主板、电池、屏幕、外壳这几种种简单的部件吗？维修起来那都是小事✨✨~</p>
</blockquote>
<p>我于上周周五将手机上音量按键摔坏了。</p>
<p>事情是这样的：那天下午回到宿舍洗衣服还是啥的，本来打算等到忙完了之后去学习。但是年纪大了，人也变懒了，我遂决定狗在宿舍玩手机! 到了傍晚天气转凉，舍友A叫我去打球，我直起我180°的老腰，兴奋的准备下床😝，顺手将手机扔到了我的床和邻床的缝隙中，手机一横冲直撞，好似放学冲入食堂那番💪，并且一路高歌直到冲到地面。把窝一个人丢在床上凌乱🤦‍♂️。这时候我似一道光冲下床拿到我的宝贝/爷爷（我妈说：手机是你爷，你天天抱着）仔细端详着它娇弱的身躯，生怕哪里碰着了，我摸了摸它的脸，完好无损，我开心的笑了，我突然发现上音量键按不动了，舍友B也开心的笑了。</p>
<p>我决定凭自己的技术医治好她！我上某宝给客服讲了讲我宝贝的情况，客服说是音量排线坏了，我立即就下单了一排线。</p>
<p>悲惨的事情就发生在本周5，我翘课将上上周的3份实验报告补完之后，我的快递到了🤸‍♂️。</p>
<p>在路上我坚信我一定可以治好她！！！回到宿舍后，我找客服要拆机视频，但是客服迟迟不回我，我给颖子哥😀道别之后（<strong>爱生活爱颖子哥</strong>），我开始了。</p>
<p>先拆外壳，用商家给我的吸盘，拔了好一会终于有个缝了，我向舍友B要刀片之类可以撬的东西，他正在玩怪物猎人，我瞅到了他桌子上的一卡通。多亏他的一卡通，我解开我宝贝的外衣。身躯净裸露在外，在此我要向B的一卡通说声谢谢😀。</p>
<p>我拔掉骨头（电源排线）并且拆除指纹排线后，我在A的钥匙上拆下了挖耳屎的勺子，我开始撬主板了，这主板是真的难撬，我费劲九牛二虎之力，这边撬下，那边撬下，功夫不负有心人，我撬开了🧎‍♂️！</p>
<p><img src="https://i.loli.net/2021/05/15/qS86vLVzDXs1dHU.jpg" alt="609fa160e7764_609fa1617e532"></p>
<p>A的勺子成了这样（A把窝骂了一顿，并把他的耳屎勺拿了回去）我只能展示下我画画的功底了！</p>
<p><img src="https://i.loli.net/2021/05/15/aRy48swZYorj12q.png" alt="image-20210515170858617"></p>
<p>知道为什么我要费九牛二虎之力吗？因为我没拔卡槽</p>
<img src="https://i.loli.net/2021/05/15/V6pFItaQiCbqmsR.jpg" width="400px" />

<p>所以这东西刚拆下来是个带弧度的直角————</p>
<p>客服说的是要换下面这个宝贝（音量排线），当我把主板拆来</p>
<img src="https://i.loli.net/2021/05/15/XDrdCQPKZaqyNjo.jpg" width="400px" />

<p>发现要换的才是下面这个宝贝（外按键）</p>
<img src="https://i.loli.net/2021/05/15/r8ClzcxZDpdwRNV.jpg" width="500px" />



<p>没错我把音量排线拔掉检查是正常的后我才开始检查是不是外按键出的问题！我真蠢👹</p>
<p>让人气愤💢的是：<strong>外按键可以不用拆主板就可以换</strong></p>
<p>最后我的机器就成了这样：🥰🥰🥰</p>
<p><img src="https://i.loli.net/2021/05/15/vU9hKfARIxdwjcP.jpg" alt="609fa1f0e8543_609fa1f161ecf"></p>
<p>所以这次拆机以失败告终！😭😭😭</p>
<p>打个广告：🥇🥇🥇🥇🥇<strong>专业修手机本人有22年修手机经验，支持门店、邮递递。欢迎各位老板甩单</strong></p>
<p>（好想颖子哥）</p>
]]></content>
      <categories>
        <category>-生活</category>
      </categories>
      <tags>
        <tag>-修手机</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈WebRTC</title>
    <url>/2021/09/07/%E6%B5%85%E8%B0%88WebRTC/</url>
    <content><![CDATA[<h1 id="浅谈WebRTC"><a href="#浅谈WebRTC" class="headerlink" title="浅谈WebRTC"></a>浅谈WebRTC</h1><h2 id="什么是webRTC"><a href="#什么是webRTC" class="headerlink" title="什么是webRTC"></a>什么是webRTC</h2><p>维基百科是这样定义的：<strong>WebRTC</strong>，名称源自<strong>网页即时通信</strong>（英语：Web Real-Time Communication）的缩写，是一个支持<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81%E7%80%8F%E8%A6%BD%E5%99%A8">网页浏览器</a>进行实时语音对话或视频对话的<a href="https://zh.wikipedia.org/wiki/API">API</a>。简单来说就是网页用来<strong>音视频通话</strong>的。</p>
<p>完成音视频需要4个模块：</p>
<h2 id="本地媒体流的采集"><a href="#本地媒体流的采集" class="headerlink" title="本地媒体流的采集"></a>本地媒体流的采集</h2><p><strong>getUserMedia</strong></p>
<p>使用<code> navigator.mediaDevices.getUserMedia( constraints );</code>获取本地的媒体流。<strong>constraints</strong>指定了请求的媒体类型和参数</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>视频宽</td>
</tr>
<tr>
<td>height</td>
<td>视频高</td>
</tr>
<tr>
<td>facingMode（user,environment）</td>
<td>镜像模式</td>
</tr>
<tr>
<td>aspectRatio</td>
<td>比例</td>
</tr>
<tr>
<td>frameRate</td>
<td>帧率</td>
</tr>
<tr>
<td>resizeMode</td>
<td>大小模式</td>
</tr>
</tbody></table>
<p>像width/height等可以用普通的关键字也可以用ideal,min,max,exact修饰，其中exact表示的是很确认的即一定意思。</p>
<h2 id="STUN-TURN-服务器"><a href="#STUN-TURN-服务器" class="headerlink" title="STUN/TURN 服务器"></a>STUN/TURN 服务器</h2><p>ICE集成了多种NAT（网络地址转化）穿越技术比如STUN、TURN。</p>
<p>在介绍STUN/TURN之前先说下NAT</p>
<p>NAT常常部署在私网到公网的路由出口，死亡设备通过NAT将内网转化为公网加入互联网</p>
<p><img src="https://i.loli.net/2021/09/07/7XLuiYSyBGCxDj8.png" alt="未命名文件 (7)"></p>
<p><strong>STUN</strong>允许唯一NAT的客户端找出自己的公网地址。</p>
<p>STUN是C/S模式的协议，客户端发送STUN请求，STUN服务响应告知由NAT分配给主机的IP地址和端口号。所以就需要先在公网上架设一台STUN服务器，像STUN服务器发送请求就能拿到公网IP</p>
<p><strong>TURN</strong>是一种数据传输协议。允许通过TCP或UDP方式穿透NAT或防火墙。</p>
<p>STUN和TRURN都是通过公网IP地址达到NAT穿透</p>
<h2 id="信令服务器"><a href="#信令服务器" class="headerlink" title="信令服务器"></a>信令服务器</h2><p>因为WebRTC的SDP和和ICE要通过服务器来传到另一个客户端上，因为SDP和ICE这些东西我们将他叫做信令，所以传输信令的服务器我们就将其称作是<strong>信令服务器</strong>了，一般利用WebSocket的实时通信能力搭建信令服务器。</p>
<p>SDP（Session Description Protocol）会话描述协议：包括浏览器所支持的编码格式以及ICE代理、MediaStreamTrack等信息</p>
<p>SPD协议结构 : &lt;type&gt; = &lt;value&gt;</p>
<h2 id="端与端之间P2P连接"><a href="#端与端之间P2P连接" class="headerlink" title="端与端之间P2P连接"></a>端与端之间P2P连接</h2><p>创建了本地的媒体流怎么把本地的媒体流和另一个客户端上的媒体流连接起来呢？</p>
<p>所以WebRTC的灵魂就是这个了<strong>peerConnection</strong>。记住了<strong>P2P全靠它</strong></p>
<p><code>pc = new RTCPeerConnection(pcConfig)</code>，好了有pc了，怎么连接呢？</p>
<p>分两步：</p>
<ol>
<li>发送端先调用createOffer创建（SDP Offer）</li>
<li>通过setLocalDescription将（SDP Offer）加入到pc中：将会话信息传递到CIE曾</li>
</ol>
<p><strong>addIceCandidate</strong>添加ICE代理</p>
<p>其实我这里大概写了一下创建P2P信息的基本流程，但是写的不清不楚，所以我先总结一下到了最后再详细的写一下创建链接的步骤。</p>
<p>总体来说：A端将自己的candidate offer 存到了B端的PC中，B端也将自己的candidate，answer存到了A端的PC中，交换完成之后AB中都有了双方SDP，这样他们可以选择他们相同的编码等，收集的ICE完成连通性检测后，P2P链接就建立成功了。</p>
<p><strong>P2P建立链接过程</strong></p>
<ol>
<li><p> AB 创建本地媒体流 （假设 A 是发送方，B 是接收方，客户端简称为 C 端，服务端简称为 S）</p>
</li>
<li><p> AB peer = new RTCPeerConnection</p>
</li>
<li><p>监听 peer 的事件</p>
<ol>
<li> onicecandidate 如果本地代理 SDP Offer 并调用后，将 candidate 发送给对方</li>
<li>onaddstream 如果有视频流就拿到视频流</li>
</ol>
</li>
<li><p> 将本地视频流添加到 peer 中</p>
</li>
<li><p> A 创建 offerA 并加入到 peerA 里</p>
</li>
<li><p> AC setLocalDescription 后会触发 onicecandidate</p>
</li>
<li><p> AC 触发 onicecandidate S 就会收到来自 AC 的 candidate</p>
</li>
<li><p> S 将 AC 的 candidate 转发到 BC, BC 将 candidate 存入到 peerB 中</p>
</li>
<li><p> AC 将 OfferA 发送给 BC</p>
</li>
<li><p> BC 接收到 offerA 后，将 offerA 存入到 peerB 中</p>
</li>
</ol>
<p>  <strong><em>**</em></strong>上面的过程后 AB 将会建立好连接，然后 A B 监听的 onaddstream 事件就会有 stream 流入*<strong>*<em>\</em></strong></p>
<p>参考文章[<a href="https://juejin.cn/post/7000205126719766565#heading-9">浅聊WebRTC视频通话 - 掘金 (juejin.cn)</a>]</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
</search>
